
^ -> :#this is the sneeze -> it defines operator precidence for the rest of the document.
! :
== != :
+ - :
* :


#syntax:
#   f(a,b,c)      <--- you call dependantly typed functions with parameters. Arguments may be supplied by name or positionally. Positional arguments may not come after named ones.
#   [a:A]B(a)     <--- this is a fibration. It represents the type of all functions/mappings from A onto B(the element of A). It also represents the universal generalization, "for all a in A: B(a)"
#   |x|f(x)       <--- this is a function/mapping. The type of x is inferred by the compiler from context clues.
#   {a:A,b:B(a)}  <--- this is a union. It represents the type of all pairs of the two types. It also represents the existential generalization, "there exists an a in A such that B(a)"
#   (a,b)         <--- this is an element of a union.
	
	# inside unions and fibrations:
	# 	a:A     <--- assert the existence of an element of A and call it a.
	# 	a:A=q   <--- define an element of A, a, as q. This can be thought of as a macro or a lemma
	# 	a:=q    <--- same as previous but you let the compiler figure out the type of a/q.
	# 	::=Q    <--- Q must be a union or a fibration into a union. imports all types in Q into the current space.


{
U:U,
#U is special. It is the type that all types and predicates have.
#Normally, there would be an infinite chain of nested universe types. My system does not support this (or subtyping), because:
	#if A is a subtype of B such that P(b), then just make A judgementally equal to the fibration from B into P(b)- it's just as powerful albiet less readable
	#the traditional kind of subtyping might make things easier for a human to understand but who cares about humans- it's more important to have a language that can be processed efficiently.
	#the kind of reasoning people do with nested universes can still be done with fibrations on U- just as powerful and arguably more understandable
	#because "has type of" is not a relation or predicate, girard's paradox cannot be expressed in this system
	#U is the only object allowed to appear in its own type.




'==':[A?:U,a:A,b:A]U,



#operator overloading-> any function that takes one or two positional arguments can be named an operator.
#the = here means any usage of == is rewritten behind the scenes to be an EQ call. == and EQ are then judgementally equivalent.
#the question mark after the A means that, when supplying positional arguments, you skip the A and just provide a and b. The compiler then tries to infer A for you.
	#the compiler can only infer variables for you when they appear in the types of arguments that you supply. It's pretty good at type inference.
#the EQ line that comes before is an alternate way to use == where you also supply the type of the other two arguments.
	#It's useful for when the compiler cannot deduce the type of the arguments you supply automatically, like in the cases (A,B)==(A,B) and (|c|c)==(|c|c)

REFLEXIVITY: [A?:U,a:A]a==a,#this is the reflexivity property of equality
SUBSTITUTION:[A?:U,a?:A,b?:A,J:[c:A,a==c]U,q:a==b,J(a,REFLEXIVITY(a))]J(b,q),#this is path induction.

SUBSTITUTE_GARUNTEE:[A?:U,a?:A,J:[c:A,a==c]U,k:J(a,REFLEXIVITY(a))]SUBSTITUTION(|w,y|J(w,y),REFLEXIVITY(a),k) == k,#this is the base case for path induction

'^':         [A?:U,a?:A,b?:A,q:b==a]a==b                     = SUBSTITUTION(|w,_|w==b,q,REFLEXIVITY(b)),#this is the symmetric property of equality. I prove it with path induction.
EQUIVALENCE: [A?:U,B?:U,a:A,q:A==B]B                         = SUBSTITUTION(|w,_|w,q,a),                            #this is a property of equality. I prove it with path induction.
PRESERVATION:[A?:U,B?:U,a?:A,b?:A,f:[A]B,q:a==b]f(a) == f(b) = SUBSTITUTION(|w,_|f(a)==f(w),q,REFLEXIVITY(f(a))),   #this is a property of equality. I prove it with path induction.
'->':        [J?:U,a?:J,b?:J,c?:J,q1:a==b,q2:b==c]a==c       = SUBSTITUTION(|w,_|a==w,q2,q1),          #this is the transitive property of equality. I prove it with path induction.



'!':[A:U]U = [A,u:U]u,#This is negation;the inhabitation of A implies the inhabitation of all things, which is a contradiction.
'!=':[A?:U,a:A,b:A]U = !(a==b),

# Types may be nested and unraveled.
#the following is actually inconsistant because of a technicality and needs to be revised......
|DEC,DEC.POSITIVE,DEC.NEGATIVE|:[T?:U,K:U,a:[K]T,b:[!K]T]{
    dec:T,#<--- This is the definition of a conditional.
    [k:K] dec==a(k),#<--- When the conditional's predicate is true, the conditional's result is equal to its first argument.
    [k:!K]dec==b(k)#<--- When the conditional's predicate is false, the conditional's result is equal to its second argument.
},
|'.'positive,'.'negative|:[K?:U,a?:[K]U,b?:[!K]U,Dec:U = DEC(K,|x|a(x),|x|b(x)),dec:Dec]{
    [pos:K]a(pos) = EQUIVALENCE(dec,Dec.POSITIVE(pos)),
    [neg:!K]b(neg) = EQUIVALENCE(dec,Dec.NEGATIVE(neg))
},
#the following block is kind of built into the language itself...
# |AND,['.'acc,'.'accb],[UNION,MEMBER,MEMBERB],AND.equal,FUNC,'.'eval,[MAKEFUNC,FUNCASSURANCE],FUNC.equal|:[A:U,B:[A]U]{#For all (types) and (types derived from the first type)...
#     and:U,
#     |acc,accb|:[c:and]{#Given an element of the type representing the union...
#         acc:A,#you may retrieve an element of the first type.
#         B(acc)#you may retrieve an element of the second type as well.
#     },
#     [a:A,b:B(a)]{#Given elements of each type...
#         union:and,#you may construct an element of the type representing the union of two types.
#         member:a == acc(union),#accessing the first element from the union gives you back the same element that you used to construct the union.
#         memberb:SUBSTITUTION(|w,_|B(w),member,b) == accb(union)#gives you back the second element except a becomes acc(union)
#     },
#     [au:and,bu:and,q:acc(au)==acc(bu),SUBSTITUTION(|w,_|B(w),q,accb(au))==accb(bu)]au==bu,#this is special; the compiler is going to try to apply this one automatically.


#     func:U,
#     eval:[func,a:A]B(a),
#     [b:[a:A]B(a)] {
#         make:func,
#         [a:A]eval(make,a) == b(a)
#     },
#     [af:func,bf:func,[a:A]eval(af,a)==eval(bf,a)]af==bf #this is special
#     # ^^^---- apparently this comes from the univalence axiom... but the proof is long and I couldn't follow it.
# },

#all the below logic is just for convenience for the user's sake. Everything below has a proof.
#this part is ugly but at least all the ugliness is confined to one file.

doublenot:[J?:U,j:J]! !J = DEC(!J,|s|s(j,! !J),|s|s),
doublenot:[J?:U,j:! !J]J = DEC(J,|s|s,|s|j(s,J)),
negate_union:[A?:U,B?:[A]U,s:!{a:A,B(a)}][x:A]!B(x) = DEC(B(x),|c|s((x,c),!B(x)),|c|c),
negate_union:[A?:U,B?:[A]U,s:!{a:A,!B(a)}][x:A]B(x) = DEC(B(x),|c|c,|c|s((x,c),B(x))),
'.'commute:[A?:U,B?:U,|a,b|:{A,B}]{B,A}=(b,a),

AND:[A:U,B:U]U = {a:A,b:B},#useful for when type inference fails.
AND.construct:[A:U,B:U,a:A,b:B]AND(A,B) = (a,b),

NAND:[A:U,B:U]U = !{A,B},
NAND.construct:[A:U,B:U,a:!A]NAND(A,B) = DEC({a:A,b:B},|s|a(s.a,NAND(A,B)),|s|s),
NAND.construct:[A:U,B:U,b:!B]NAND(A,B) = DEC({a:A,b:B},|s|b(s.b,NAND(A,B)),|s|s),
'.'extract:[A?:U,B?:U,o:NAND(A,B),na:A]!B = DEC(B,|s|o((na,s),!B),|s|s),
'.'extract:[A?:U,B?:U,o:NAND(A,B),nb:B]!A = DEC(A,|s|o((s,nb),!A),|s|s),
'.'commute:[A?:U,B?:U,o:NAND(A,B)]NAND(B,A) = DEC({b:B,a:A},|s|o((s.a,s.b),NAND(B,A)),|s|s),


OR:[A:U,B:U]U = !{!A,!B},
OR.construct:[A:U,B:U,a:A]OR(A,B) = DEC({a:!A,b:!B},|s|s.a(a,OR(A,B)),|s|s),
OR.construct:[A:U,B:U,b:B]OR(A,B) = DEC({a:!A,b:!B},|s|s.b(b,OR(A,B)),|s|s),
'.'extract:[A?:U,B?:U,o:OR(A,B),na:!A]B = DEC(B,|s|s,|s|o((na,s),B)),
'.'extract:[A?:U,B?:U,o:OR(A,B),nb:!B]A = DEC(A,|s|s,|s|o((s,nb),A)),
'.'commute:[A?:U,B?:U,o:OR(A,B)]OR(B,A) = DEC({b:!B,a:!A},|s|o((s.a,s.b),OR(B,A)),|s|s),

SYMIMPLIES:[A:U,B:U]U = {a:[B]A,b:[A]B},

XOR:[A:U,B:U]U = !{[B]A,[A]B},
XOR.construct:[A:U,B:U,a:A,b:!B]XOR(A,B) = DEC({a:[B]A,b:[A]B},|s|b(s.b(a),XOR(A,B)),|s|s),
XOR.construct:[A:U,B:U,a:!A,b:B]XOR(A,B) = DEC({a:[B]A,b:[A]B},|s|a(s.a(b),XOR(A,B)),|s|s),
'.'extract:[A?:U,B?:U,o:XOR(A,B),na:!A]B = DEC(B,|s|s,|s|o((|xb|s(xb,A),|xa|na(xa,B)),B)),
'.'extract:[A?:U,B?:U,o:XOR(A,B),nb:!B]A = DEC(A,|s|s,|s|o((|xb|nb(xb,A),|xa|s(xa,B)),A)),
'.'extract:[A?:U,B?:U,o:XOR(A,B),a:A]!B  = DEC(B,|s|o((|_|a,|_|s),!B),|s|s),
'.'extract:[A?:U,B?:U,o:XOR(A,B),b:B]!A  = DEC(A,|s|o((|_|s,|_|b),!A),|s|s),
'.'commute:[A?:U,B?:U,o:XOR(A,B)]XOR(B,A) = DEC({a:[A]B,b:[B]A},|s|o((s.b,s.a),XOR(B,A)),|s|s)
,

#[0] [1]  2   3
#[0]  1  [2]  3
#[0]  1   2  [3]
TRIPLE_OR:[A:U,B:U,C:U]U = !{!A,!B,!C},                                      #[0]  1   2   3
	TRIPLE_OR.construct:[A:U,B:U,C:U,a:A]TRIPLE_OR(A,B,C) = DEC({a:!A,b:!B,c:!C},|s|s.a(a,!{!A,!B,!C}),|s|s),
	TRIPLE_OR.construct:[A:U,B:U,C:U,b:B]TRIPLE_OR(A,B,C) = DEC({a:!A,b:!B,c:!C},|s|s.b(b,!{!A,!B,!C}),|s|s),
	TRIPLE_OR.construct:[A:U,B:U,C:U,c:C]TRIPLE_OR(A,B,C) = DEC({a:!A,b:!B,c:!C},|s|s.c(c,!{!A,!B,!C}),|s|s),
	'.'T_OR_extract:[A?:U,B?:U,C?:U,o:TRIPLE_OR(A,B,C),a:!A,b:!B]C = DEC(C,|s|s,|s|o((a,b,s),C)),
	'.'T_OR_extract:[A?:U,B?:U,C?:U,o:TRIPLE_OR(A,B,C),b:!B,c:!C]A = DEC(A,|s|s,|s|o((s,b,c),A)),
	'.'T_OR_extract:[A?:U,B?:U,C?:U,o:TRIPLE_OR(A,B,C),c:!C,a:!A]B = DEC(B,|s|s,|s|o((a,s,c),B)),
	'.'commute:[A?:U,B?:U,C?:U,o:TRIPLE_OR(A,B,C)]TRIPLE_OR(A,C,B) = DEC({a:!A,c:!C,b:!B},|s|o((s.a,s.b,s.c),TRIPLE_OR(A,C,B)),|s|s),
	'.'cycle:  [A?:U,B?:U,C?:U,o:TRIPLE_OR(A,B,C)]TRIPLE_OR(B,C,A) = DEC({b:!B,c:!C,a:!A},|s|o((s.a,s.b,s.c),TRIPLE_OR(B,C,A)),|s|s),
	'.'T_OR_case_by_case:[A?:U,B?:U,C?:U,o:TRIPLE_OR(A,B,C),T?:U,at:[A]T,bt:[B]T,ct:[C]T]T = DEC(A,at,|na|DEC(B,bt,|nb|ct(o.T_OR_extract(na,nb)))),

TRIPLE_AND:[A:U,B:U,C:U] = {a:A,b:B,c:C},                                    #[0] [1] [2]  3 
TWO_OF:[A:U,B:U,C:U]U = !{[A,B]C,[B,C]A,[C,A]B},                             #[0] [1]  2  [3]
	TWO_OF.construct:[A:U,B:U,C:U,a:A,b:B,nc:!C]TWO_OF(A,B,C) = DEC({c:[A,B]C,a:[B,C]A,b:[C,A]B},|s|nc(s.c(a,b),TWO_OF(A,B,C)),|s|s),
	TWO_OF.construct:[A:U,B:U,C:U,a:A,nb:!B,c:C]TWO_OF(A,B,C) = DEC({c:[A,B]C,a:[B,C]A,b:[C,A]B},|s|nb(s.b(c,a),TWO_OF(A,B,C)),|s|s),
	TWO_OF.construct:[A:U,B:U,C:U,na:!A,b:B,c:C]TWO_OF(A,B,C) = DEC({c:[A,B]C,a:[B,C]A,b:[C,A]B},|s|na(s.a(b,c),TWO_OF(A,B,C)),|s|s),
	'.'TWO_OF_extract:[A?:U,B?:U,C?:U,o:TWO_OF(A,B,C),a:!A]{b:B,c:C} = (
		DEC(B,|s|s,|s|o((|ax,bx|s(bx,C),|bx,cx|s(bx,A),|cx,ax|a(ax,B)),B)),
		DEC(C,|s|s,|s|o((|ax,bx|a(ax,C),|bx,cx|s(cx,A),|cx,ax|s(cx,B)),C))
	),
	'.'TWO_OF_extract:[A?:U,B?:U,C?:U,o:TWO_OF(A,B,C),b:!B]{c:C,a:A} = (
		DEC(C,|s|s,|s|o((|ax,bx|b(bx,C),|bx,cx|s(cx,A),|cx,ax|s(cx,B)),C)),
		DEC(A,|s|s,|s|o((|ax,bx|s(ax,C),|bx,cx|b(bx,A),|cx,ax|s(ax,B)),A))
	),
	'.'TWO_OF_extract:[A?:U,B?:U,C?:U,o:TWO_OF(A,B,C),c:!C]{a:A,b:B} = (
		DEC(A,|s|s,|s|o((|ax,bx|s(ax,C),|bx,cx|c(cx,A),|cx,ax|s(ax,B)),A)),
		DEC(B,|s|s,|s|o((|ax,bx|s(bx,C),|bx,cx|s(bx,A),|cx,ax|c(cx,B)),B))
	),
	'.'TWO_OF_extract:[A?:U,B?:U,C?:U,o:TWO_OF(A,B,C),a:A]XOR(B,C) = DEC({b:[C]B,c:[B]C},|s|o((|ax,bx|s.c(bx),|bx,cx|a,|cx,ax|s.b(cx)),XOR(B,C)),|s|s),
	'.'TWO_OF_extract:[A?:U,B?:U,C?:U,o:TWO_OF(A,B,C),b:B]XOR(C,A) = DEC({c:[A]C,a:[C]A},|s|o((|ax,bx|s.c(ax),|bx,cx|s.a(cx),|cx,ax|b),XOR(C,A)),|s|s),
	'.'TWO_OF_extract:[A?:U,B?:U,C?:U,o:TWO_OF(A,B,C),c:C]XOR(A,B) = DEC({a:[B]A,b:[A]B},|s|o((|ax,bx|c,|bx,cx|s.a(bx),|cx,ax|s.b(ax)),XOR(A,B)),|s|s),
	'.'commute:[A?:U,B?:U,C?:U,o:TWO_OF(A,B,C)]TWO_OF(A,C,B) = DEC({b:[A,C]B,a:[C,B]A,c:[B,A]C},|s|o((|a,b|s.c(b,a),|b,c|s.a(c,b),|c,a|s.b(a,c)),TWO_OF(A,C,B)),|s|s),
	'.'cycle:  [A?:U,B?:U,C?:U,o:TWO_OF(A,B,C)]TWO_OF(B,C,A) = DEC({a:[B,C]A,b:[C,A]B,c:[A,B]C},|s|o((s.c,s.a,s.b),TWO_OF(B,C,A)),|s|s),
AT_LEAST_TWO_OF:[A:U,B:U,C:U]U = TRIPLE_OR({A,B},{B,C},{C,A}),               #[0] [1]  2   3 
	AT_LEAST_TWO_OF.construct:[A:U,B:U,C:U,a:A,b:B]AT_LEAST_TWO_OF(A,B,C) = TRIPLE_OR({A,B},{B,C},{C,A}).construct(AND(A,B).construct(a,b)),
	AT_LEAST_TWO_OF.construct:[A:U,B:U,C:U,b:B,c:C]AT_LEAST_TWO_OF(A,B,C) = TRIPLE_OR({A,B},{B,C},{C,A}).construct(AND(B,C).construct(b,c)),
	AT_LEAST_TWO_OF.construct:[A:U,B:U,C:U,c:C,a:A]AT_LEAST_TWO_OF(A,B,C) = TRIPLE_OR({A,B},{B,C},{C,A}).construct(AND(C,A).construct(c,a)),
	'.'ATLEAST_TWO_OF_extract:[A?:U,B?:U,C?:U,o:AT_LEAST_TWO_OF(A,B,C),na:!A]{B,C} = o.T_OR_extract(DEC({c:C,a:A},|s|na(s.a,!{c:C,a:A}),|s|s),DEC({a:A,b:B},|s|na(s.a,!{c:A,a:B}),|s|s)),
	'.'ATLEAST_TWO_OF_extract:[A?:U,B?:U,C?:U,o:AT_LEAST_TWO_OF(A,B,C),nb:!B]{C,A} = o.T_OR_extract(DEC({a:A,b:B},|s|nb(s.b,!{c:A,a:B}),|s|s),DEC({b:B,c:C},|s|nb(s.b,!{c:B,a:C}),|s|s)),
	'.'ATLEAST_TWO_OF_extract:[A?:U,B?:U,C?:U,o:AT_LEAST_TWO_OF(A,B,C),nc:!C]{A,B} = o.T_OR_extract(DEC({b:B,c:C},|s|nc(s.c,!{c:B,a:C}),|s|s),DEC({c:C,a:A},|s|nc(s.c,!{c:C,a:A}),|s|s)),
ONE_OF:[A:U,B:U,C:U]U = !{ab:[C]OR(A,B),bc:[A]OR(B,C),ca:[B]OR(C,A)},        #[0]  1  [2] [3]
TRIPLE_XOR:[A:U,B:U,C:U]U = !{ab:[C]XOR(A,B),bc:[A]XOR(B,C),ca:[B]XOR(C,A)}, #[0]  1  [2]  3
ONE_OR_TWO_OF:[A:U,B:U,C:U]U = !{bc:[A]{B,C},ca:[B]{C,A},ab:[C]{A,B}},       #[0]  1   2  [3]




AT_MOST_TWO_OF:[A:U,B:U,C:U]U = !{A,B,C},#0 1 2 [3]
	AT_MOST_TWO_OF.construct:[A:U,B:U,C:U,na:!A]AT_MOST_TWO_OF(A,B,C) = DEC({a:A,b:B,c:C},|s|na(s.a,!{A,B,C}),|s|s),
	AT_MOST_TWO_OF.construct:[A:U,B:U,C:U,nb:!B]AT_MOST_TWO_OF(A,B,C) = DEC({a:A,b:B,c:C},|s|nb(s.b,!{A,B,C}),|s|s),
	AT_MOST_TWO_OF.construct:[A:U,B:U,C:U,nc:!C]AT_MOST_TWO_OF(A,B,C) = DEC({a:A,b:B,c:C},|s|nc(s.c,!{A,B,C}),|s|s),
	'.'extract:[A?:U,B?:U,C?:U,o:AT_MOST_TWO_OF(A,B,C),a:A,b:B]!C = DEC(C,|s|o((a,b,s),!C),|s|s),
	'.'extract:[A?:U,B?:U,C?:U,o:AT_MOST_TWO_OF(A,B,C),b:B,c:C]!A = DEC(A,|s|o((s,b,c),!A),|s|s),
	'.'extract:[A?:U,B?:U,C?:U,o:AT_MOST_TWO_OF(A,B,C),c:C,a:A]!B = DEC(B,|s|o((a,s,c),!B),|s|s),
	'.'commute:[A?:U,B?:U,C?:U,o:AT_MOST_TWO_OF(A,B,C)]AT_MOST_TWO_OF(A,C,B) = DEC({a:A,c:C,b:B},|s|o((s.a,s.b,s.c),!{A,C,B}),|s|s),
	'.'cycle:  [A?:U,B?:U,C?:U,o:AT_MOST_TWO_OF(A,B,C)]AT_MOST_TWO_OF(B,C,A) = DEC({b:B,c:C,a:A},|s|o((s.a,s.b,s.c),!{B,C,A}),|s|s),

AT_MOST_ONE_OF:[A:U,B:U,C:U]U = {ab:!{A,B},bc:!{B,C},ca:!{C,A}}, #0 1 [2] [3]
	AT_MOST_ONE_OF.construct:[A:U,B:U,C:U,na:!A,nb:!B]AT_MOST_ONE_OF(A,B,C) = (DEC({a:A,b:B},|s|na(s.a,!{A,B}),|s|s),DEC({b:B,c:C},|s|nb(s.b,!{B,C}),|s|s),DEC({c:C,a:A},|s|na(s.a,!{C,A}),|s|s)),
	AT_MOST_ONE_OF.construct:[A:U,B:U,C:U,nb:!B,nc:!C]AT_MOST_ONE_OF(A,B,C) = (DEC({a:A,b:B},|s|nb(s.b,!{A,B}),|s|s),DEC({b:B,c:C},|s|nb(s.b,!{B,C}),|s|s),DEC({c:C,a:A},|s|nc(s.c,!{C,A}),|s|s)),
	AT_MOST_ONE_OF.construct:[A:U,B:U,C:U,nc:!C,na:!A]AT_MOST_ONE_OF(A,B,C) = (DEC({a:A,b:B},|s|na(s.a,!{A,B}),|s|s),DEC({b:B,c:C},|s|nc(s.c,!{B,C}),|s|s),DEC({c:C,a:A},|s|nc(s.c,!{C,A}),|s|s)),
	'.'extract:[A?:U,B?:U,C?:U,o:AT_MOST_ONE_OF(A,B,C),a:A]{b:!B,c:!C} = (DEC(B,|s|o.ab((a,s),!B),|s|s),DEC(C,|s|o.ca((s,a),!C),|s|s)),
	'.'extract:[A?:U,B?:U,C?:U,o:AT_MOST_ONE_OF(A,B,C),b:B]{c:!C,a:!A} = (DEC(C,|s|o.bc((b,s),!C),|s|s),DEC(A,|s|o.ab((s,b),!A),|s|s)),
	'.'extract:[A?:U,B?:U,C?:U,o:AT_MOST_ONE_OF(A,B,C),c:C]{a:!A,b:!B} = (DEC(A,|s|o.ca((c,s),!A),|s|s),DEC(B,|s|o.bc((s,c),!B),|s|s)),
	'.'commute:[A?:U,B?:U,C?:U,o:AT_MOST_ONE_OF(A,B,C)]AT_MOST_ONE_OF(A,C,B) = (o.ca.commute,o.bc.commute,o.ab.commute),
	'.'cycle:  [A?:U,B?:U,C?:U,o:AT_MOST_ONE_OF(A,B,C)]AT_MOST_ONE_OF(B,C,A) = (o.bc,o.ca,o.ab),




TRIPLE_NOR:[A:U,B:U,C:U]U = {a:!A,b:!B,c:!C},#0 [1] [2] [3]
	TRIPLE_NOR.construct:[A:U,B:U,C:U,na:!A,nb:!B,nc:!C]TRIPLE_NOR(A,B,C) = (na,nb,nc)#,

# A:U,
# B:[A]U,
# C:[a:A,b:B(a)]U,
# D:[a:A,b:B(a),c:C(a,b)]U,

# a1:A,
# a2:A,
# b1:B(a1),
# b2:B(a2),
# c1:C(a1,b1),
# c2:C(a2,b2),
# d1:D(a1,b1,c1),
# d2:D(a2,b2,c2),
# a:a1 == a2,
# b:'=='(SUBSTITUTION(|a,_|B(a),a,b1,A=A,a=a1,b=a2),b2,A=B(a2)),
# c:SUBSTITUTION(|[a,b],_|C(a,b),(a,b),c1,A={a:A,B(a)},a=(a1,b1),b=(a2,b2)) == c2,
# d:SUBSTITUTION(|[a,b,c],_|D(a,b,c),(a,b,c),d1,A={a:A,b:B(a),c:C(a,b)},a=(a1,b1,c1),b=(a2,b2,c2)) == d2

# # tape is both input and output.<<<<

# ,
# a:a1 == a2,
# |b,c|:SUBSTITUTION(A,a1,a2,|a,_|B(a),a,b1) == b2,
# d:SUBSTITUTION({a:A,B(a)},(a1,b1),(a2,b2),|[a,b],_|C(a,b),(a,b),c1) == c2

}





# K:U,
# A:f(K)
# D:[d(A)]U
# X:D(A) <--- tries to disable K...


# TRIPLE_XOR:[A:U,B:U,C:U]U = {c:[A,B]C,a:[B,C]A,b:[C,A]B,or:TRIPLE_OR(A,B,C)},
# '.'commute:[A?:U,B?:U,C?:U,o:TRIPLE_XOR(A,B,C)]TRIPLE_XOR(A,C,B) = (o.a,o.c,o.b,o.or.commute),
# '.'cycle:  [A?:U,B?:U,C?:U,o:TRIPLE_XOR(A,B,C)]TRIPLE_XOR(B,C,A) = (o.a,o.b,o.c,o.or.cycle),


# lambdaless flag..........



# negate_union:[A?:U,B?:[A]U,!{a:A,B(a)},a:A]B(a),
# negate_union:[A?:U,B?:[A]U,C?:[a:A,B(a)]U,!{a:A,b:B(a),c:C(a,b)},a:A,b:B(a)]C(a,b)




 
# !([a:A]B(a)) == {a:A,!B(a)}




# [A?:U,?B:[A]U,c:{a:A,B(a)}]c == (c.a,c.b)
#  [?A:U,?B:[A]U,b:B,curried:B = |c|b(c),a:A]b(a) == curried(a)

#  [A:U,B:[A]U,a1:A,b1:B(a1),a2:A,b2:B(a2)]
#  EQ({a:A,B(a)},(a1,b1),(a2,b2)) == {c:a1==a2,SUBSTITUTION(|w,_|B(w),b1,c) == b2}
#  [A:U,B:[A]U,b1:[a1:A]B(a1),b2:[a2:A]B(a2)]
#  EQ(B,|a|b1(a),|a|b2(a)) == ([a:A]b1(a) == b2(a))

#  [?J:U,?x:J,?y:J,A:[c:A,x==c]U,B:[c:A,cq:x==c,A(c,cq)]U,q:x==y,a:A(x,REFLEXIVITY(x)),b:B(x,REFLEXIVITY(x),a)]
#  SUBSTITUTION(|w,wq|{a:A(w,wq),B(w,wq,a)},q,(a,b))
#  ==
#  (
#     SUBSTITUTION(|w,wq|A(w,wq),q,a),
#     SUBSTITUTION(
#         |w,wq|B(w,wq,SUBSTITUTION(|w,wq|A(w,wq),wq,a)),
#         q,
#         SUBSTITUTION(
#             |w,_|B(x,REFLEXIVITY(x),w),
#             ^SUBSTITUTE_GARUNTEE(|w,wq|A(w,wq),a),
#             b
#         )
#     )
#  )

#  [?J:U,?x:J,?y:J,A:[c:A,x==c]U,B:[c:A,cq:x==c,A(c,cq)]U,q:x==y,b:[a:A(x,REFLEXIVITY(x))]B(x,REFLEXIVITY(x),a)]
#  SUBSTITUTION(|w,wq|[a:A(w,wq)]B(w,wq,a),q,b)
#  ==
#  (|a|SUBSTITUTION(
#     |w,wq|B(w,wq,SUBSTITUTION(|w,wq|A(w,wq),wq,a)),
#     q,
#     SUBSTITUTION(
#         |w,_|B(x,REFLEXIVITY(x),w),
#         ^SUBSTITUTE_GARUNTEE(|w,wq|A(w,wq),a),
#         b(SUBSTITUTION(A(w,wq),^q,a))
#     )
#  ))



#  eq_combine:[?A:U,?B:[A]U,?a1:A,?b1:B(a1),?a2:A,?b2:B(a2),aq:a1==a2,bq:SUBSTITUTION(|w,wq|B(w),aq,b1)==b2]
#     EQ({a:A,B(a)},(a1,b1),(a2,b2))



#  eq_unnest:[]


#  best way to provide the fact that functions are equal...?

# A:U
# B:[A]U
# C:[a:A,B(a)]U

# {a:A,b:B(a),c:C(a,b)}



#  {asdf} === {asdf}
#  -each row that has no type reference to another row will simply provide the ==.
#  -rows marked as compactible are omitted completely.
#  -rows where the solution is identity is omitted completely.
#  -substitutions over unions are automatically split up.
#  -substitutions over functions are automatically split up.
#  -constant substitutions are automatically eliminated.





#  {a:A,b:P(a),c:K(b)} <-- impossible; will never occur


#  {a:A,b:B,c:K(a,b)} <-- possible; will occur

#  {a:A,b:P(a),c:K(a,b)} <-- possible; will occur

# A:U,
# B:[A]U,
# C:[a:A,b:B(a)]U,
# a1:A,
# a2:A,
# b1:B(a1),
# b2:B(a2),
# c1:C(a1,b1),
# c2:C(a2,b2),


# SUBSTITUTION:[A?:U,a?:A,b?:A,J:[c:A,a==c]U,q:a==b,J(a,REFLEXIVITY(a))]J(b,q),#this is path induction.



# SUBSTITUTION(
# 	|wb,_|C(a2,wb),
# 	b,
# 	SUBSTITUTION(
# 		|wa,waq|C(wa,SUBSTITUTION(|wb,_|B(wb),waq,b1)),
# 		a,

# 	)#C(a1,b1)->C(a2,SUBSTITUTION(|w,_|B(w),a,b1))
# ),


# C(a2,b2) = 
# SUBSTITUTION(
# 	|wb,qb|


# 	SUBSTITUTION(
# 		|wa,qa|C(wa,SUBSTITUTION(|w,_|B(wa),qa,b1)),
# 		a,
# 		c1
# 	),
# 	b




# )





 # SUBSTITUTION(|[a,b],_|C(a,b),(a,b),c1)




#  {a:A,b:B(a),c:C(a,b)}

#  










#  for function and union types: ----> leftmost is topmost

#  K(a,b) are you substituting a or b first? a.

#  SUBSTITUTION(
#     |w,wq|{}

#  )



#  SUBSTITUTION(|w,wq|[A(w,wq)]B(w,wq),q,yo)(SUBSTITUTION(|w,wq|A(w,wq),q,inp))
#  == 
#  SUBSTITUTION( |w,wq|B(w,wq),q,yo(inp) )





# autocast to func when there are insufficient parameters.






# |homomorph_body,HOMOMORPH| := [A:U,B:U]{#univalent foundations but not homotopy type theory; this type theory system does not support subtyping.
#     homomorph_body := {
#         f:[A]B,
#         g:[B]A,
#         gf:[a:A]g(f(a))==a,
#         fg:[b:B]f(g(b))==b
#     },
#     (A==B) == homomorph_body
# },

# uni:[A?:U,B?:U]U = {
#     uni_block:homomorph_body(A==B,homomorph_body(A,B)) = SUBSTITUTION(
#         |w,_|w,
#         HOMOMORPH(HOMOMORPH(A,B),homomorph_body(A==B,homomorph_body(A,B))),
#         HOMOMORPH(A,B)
#     ),
#     eq_implies:[q:A==B]homomorph_body(A,B) = uni_block.f(q),
#     implies_eq:[f:[A]B,g:[B]A,gf:[a:A]g(f(a))==a,fg:[b:B]f(g(b))==b]A==B = uni_block.g((f,g,|a|gf(a),|b|fg(b)))
# }


# UNION_TOOLS: {
#     |distributive_contractability|:[?A:U,?B:[A]U]{
#         [q1:[x:A,y:A]x==y,q2:[z:A,u:B(z),v:B(z)]u==v,c:AND(A,B),d:AND(A,B)]c==d = 
#             AND(A,|a|B(a)).equal(
#                 c,d
#                 q1(c.acc,d.acc),q2(SUBSTITUTION(|w,_|B(w),q1(c.acc,d.acc),c.accb),d.accb)
#             )
#     }
# }


# UNIVALENCE_TOOLS:{
#     split_substitution:[?A:U,?a:A,?b:A,J:[c:A,a==c,d:A,a==d]U,q:a==b,k:J(a,REFLEXIVITY(a),a,REFLEXIVITY(a))]SUBSTITUTION(|w,wq|f(w,wq,w,wq),q,k) ==
#         SUBSTITUTION(
#             |w,wq|f(w,wq,b,q),q,
#             SUBSTITUTION(|w,wq|f(a,REFLEXIVITY(a),w,wq),q,k)
#         ) = 
#         SUBSTITUTION(
#             |y,yq|SUBSTITUTION(|w,wq|f(w,wq,w,wq),yq,k) == 
#                 SUBSTITUTION(
#                     |w,wq|f(w,wq,y,yq),yq,
#                     SUBSTITUTION(|w,wq|f(a,REFLEXIVITY(a),w,wq),yq,k)
#                 ),
#             q,
#             SUBSTITUTE_GARUNTEE(|w,wq|f(w,wq,w,wq),k) ->
#             SUBSTITUTION(
#                 |w,_|k == SUBSTITUTION(|w,wq|f(w,wq,a,REFLEXIVITY(a)),REFLEXIVITY(a),w),
#                 ^SUBSTITUTE_GARUNTEE(|w,wq|f(a,REFLEXIVITY(a),w,wq),k)
#                 ^SUBSTITUTE_GARUNTEE(|w,wq|f(w,wq,a,REFLEXIVITY(a)),k)
#             )
#         ),

#     contractible_fiber:[J:U,j:T,a:{g:J,y:j==g},b:{g:J,y:j==g}]a==b = 
#         SUBSTITUTION(
#             |q,qw|(a.g,a.y) =({g:J,y:j==g})= (q,qw),
#             b.y,
#             SUBSTITUTION(
#                 |q,qw|(q,qw) =({g:J,y:j==g})= (j,REFLEXIVITY(j)),
#                 a.y,
#                 REFLEXIVITY({g:J,y:j==g},(j,REFLEXIVITY(j)))
#             )
#         ),
#     equiv_contract:[?J:U,?T:U,q1:T==J,q2:[a:T,b:T]a==b,a:J,b:J]a==b = 
#         SUBSTITUTION(
#             |w,_|FUNC(w,|a|FUNC(w,|b|a==b)),
#             q1,
#             q2
#         ).eval(a).eval(b)


#     substitute_injective:[?A:U,?a:A,?b:A,f:[c:A,a==c]U,k:f(a,REFLEXIVITY(a)),l:f(a,REFLEXIVITY(a)),q:a==b,g:SUBSTITUTION(|w,wq|f(w,wq),q,k)==SUBSTITUTION(|w,wq|f(w,wq),q,l)]k==l =
#         SUBSTITUTION(
#             |w,wq|FUNC(SUBSTITUTION(|w,wq|f(w,wq),wq,k)==SUBSTITUTION(|w,wq|f(w,wq),wq,l),|_|k==l),
#             q,
#             FUNC(SUBSTITUTION(|w,wq|f(w,wq),wq,k)==SUBSTITUTION(|w,wq|f(w,wq),wq,l),
#                 |y|^SUBSTITUTE_GARUNTEE(|w,wq|f(w,wq),k) -> y -> SUBSTITUTE_GARUNTEE(|w,wq|f(w,wq),l))
#             SUBSTITUTE_GARUNTEE(|w,wq|f(w,wq),k)
#         ).eval(g),



#     nothingpath:[?A:U,?a:A,?b:A,?J:U,k:J,q:a==b]SUBSTITUTION(|_,_|J,q,k) == k = 
#         SUBSTITUTION(
#             |_,wq|SUBSTITUTION(|_,_|J,wq,k) == k,
#             q,
#             SUBSTITUTE_GARUNTEE(A,a,|_,_|J,k)
#         ),
        

#     func_sub_distrib:[
#         ?J:U,?a:J,?b:J,
#         A:[c:A,a==c]U,
#         B:[c:A,a==c]U,
#         q:a==b,
#         yo:FUNC(A(a,REFLEXIVITY(a)),|_|B(a,REFLEXIVITY(a))),
#         inp:A(a,REFLEXIVITY(a))
#     ]
#         SUBSTITUTION(
#             |w,wq|FUNC(A(w,wq),|_|B(w,wq)),q,yo
#         ).eval(SUBSTITUTION(|w,wq|A(w,wq),q,inp)) == SUBSTITUTION(|w,wq|B(w,wq),q,yo.eval(inp)) =
#         ^SUBSTITUTE_GARUNTEE(
#             |w,wq|B(w,wq),
#             SUBSTITUTION(
#                 |w,wq|FUNC(A(w,wq),|_|B(w,wq)),q,yo
#             ).eval(SUBSTITUTION(|w,wq|A(w,wq),q,inp))
#         ) ->
#         SUBSTITUTION(
#             |w,q|SUBSTITUTION(
#                 |w,wq|B(w,wq),
#                 REFLEXIVITY(w),
#                 SUBSTITUTION(
#                     |w,wq|FUNC(A(w,wq),|_|B(w,wq)),WQ,yo
#                 ).eval(SUBSTITUTION(|w,wq|A(w,wq),WQ,inp))
#             ) ==
#             SUBSTITUTION(
#                 |w,wq|B(w,wq),
#                 WQ,
#                 SUBSTITUTION(
#                     |w,wq|FUNC(A(w,wq),|_|B(w,wq)),REFLEXIVITY(a),yo
#                 ).eval(SUBSTITUTION(|w,wq|A(w,wq),REFLEXIVITY(a),inp))
#             ),
#             q,
#             REFLEXIVITY(
#                 SUBSTITUTION(
#                     |w,wq|B(w,wq),
#                     REFLEXIVITY(a),
#                     SUBSTITUTION(
#                         |w,wq|FUNC(A(w,wq),|_|B(w,wq)),REFLEXIVITY(a),yo
#                     ).eval(SUBSTITUTION(|w,wq|A(w,wq),REFLEXIVITY(a),inp))
#                 )
#             )
#         ) ->
#         PRESERVATION(
#             |w|w.eval(SUBSTITUTION(|w,wq|A(w,wq),REFLEXIVITY(a),inp)),
#             SUBSTITUTE_GARUNTEE(|w,wq|FUNC(A(w,wq),|_|B(w,wq)),yo)
#         ) ->
#         PRESERVATION(
#             |w|yo.eval(w),
#             SUBSTITUTE_GARUNTEE(|w,wq|A(w,wq),inp)
#         ),


#     union_sub_distrib_a:[
#         ?J:U,?a:J,?b:J,
#         A:[c:A,a==c]U,
#         B:[c:A,cq:a==c,A(c,cq)]U,
#         q:a==b,
#         isn:AND(A(a,REFLEXIVITY(a)),|c|B(a,REFLEXIVITY(a),c)),
#     ]
#         SUBSTITUTION(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),q,isn).acc == SUBSTITUTION(|w,wq|A(w,wq),q,isn.acc) = 
#         ^SUBSTITUTE_GARUNTEE(
#             |w,wq|A(w,wq),
#             SUBSTITUTION(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),q,isn).acc
#         ) ->
#         SUBSTITUTION(
#             |w,wq|
#             SUBSTITUTION(|w,wq|A(w,wq),REFLEXIVITY(w),SUBSTITUTION(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),wq,isn).acc) ==
#             SUBSTITUTION(|w,wq|A(w,wq),wq,SUBSTITUTION(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),REFLEXIVITY(a),isn).acc),
#             q,
#             REFLEXIVITY(
#                 SUBSTITUTION(|w,wq|A(w,wq),REFLEXIVITY(a),SUBSTITUTION(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),REFLEXIVITY(a),isn).acc)
#             )
#         ) ->
#         PRESERVATION(
#             |y|SUBSTITUTION(|w,wq|A(w,wq),wq,y.acc),
#             SUBSTITUTE_GARUNTEE(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),isn)
#         )



#     substitute_annhialate:[?J:U,?x:J,?y:J,q:x==y,I:[J]U,k:I(x)]
#         SUBSTITUTION(|w,_|I(w),q,SUBSTITUTION(|w,_|I(w),^q,k)) == k = 
#         SUBSTITUTION(
#             |_,wq|SUBSTITUTION(|w,_|I(w),wq,SUBSTITUTION(|w,_|I(w),^wq,k)) == k,
#             q
#             SUBSTITUTION(
#                 |w,_|SUBSTITUTION(|w,_|I(w),REFLEXIVITY(x),w) == k,
#                 SUBSTITUTION(
#                     |w,_|k == SUBSTITUTION(|w,_|I(w),w,k)
#                     ^sub_id_inverse(x),
#                     ^SUBSTITUTE_GARUNTEE(|w,_|I(w),k),
#                 ),
#                 SUBSTITUTE_GARUNTEE(|w,_|I(w),k)
#             )
#         ),







 

# }







#     union_sub_distrib_a:[
#         ?J:U,?a:J,?b:J,
#         A:[c:A,a==c]U,
#         B:[c:A,cq:a==c,A(c,cq)]U,
#         q:a==b,
#         isn:AND(A(a,REFLEXIVITY(a)),|c|B(a,REFLEXIVITY(a),c)),
#     ]
#         SUBSTITUTION(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),q,isn).acc == SUBSTITUTION(|w,wq|A(w,wq),q,isn.acc) = 



#         you need to do better. the full shabang. with the unions, just like function extensionality distribution.











