
^ -> :#this is the sneeze -> it defines operator precidence for the rest of the document.
! :
== != :
+ - :
* :


#syntax:
#   f(a,b,c)      <--- you call dependantly typed functions with parameters. Arguments may be supplied by name or positionally. Positional arguments may not come after named ones.
#   [a:A]B(a)     <--- this is a fibration. It represents the type of all functions/mappings from A onto B(the element of A). It also represents the universal generalization, "for all a in A: B(a)"
#   |x|f(x)       <--- this is a function/mapping. The type of x is inferred by the compiler from context clues.
#   {a:A,b:B(a)}  <--- this is a union. It represents the type of all pairs of the two types. It also represents the existential generalization, "there exists an a in A such that B(a)"
#   (a,b)         <--- this is an element of a union.
	
	# inside unions and fibrations:
	# 	a:A     <--- assert the existence of an element of A and call it a.
	# 	a:A=q   <--- define an element of A, a, as q. This can be thought of as a macro or a lemma
	# 	a:=q    <--- same as previous but you let the compiler figure out the type of a/q.
	# 	::=Q    <--- Q must be a union or a fibration into a union. imports all types in Q into the current space.


{
U:U,
#U is special. It is the type that all types and predicates have.
#Normally, there would be an infinite chain of nested universe types. My system does not support this (or subtyping), because:
	#if A is a subtype of B such that P(b), then just make A judgementally equal to the fibration from B into P(b)- it's just as powerful albiet less readable
	#the traditional kind of subtyping might make things easier for a human to understand but who cares about humans- it's more important to have a language that can be processed efficiently.
	#the kind of reasoning people do with nested universes can still be done with fibrations on U- just as powerful and arguably more understandable
	#because "has type of" is not a relation or predicate, girard's paradox cannot be expressed in this system
	#U is the only object allowed to appear in its own type.

EQ:[A:U,A,A]U,
'==':[A?:U,a:A,b:A]U = EQ(A,a,b),
#operator overloading-> any function that takes one or two positional arguments can be named an operator.
#the = here means any usage of == is rewritten behind the scenes to be an EQ call. == and EQ are then judgementally equivalent.
#the question mark after the A means that, when supplying positional arguments, you skip the A and just provide a and b. The compiler then tries to infer A for you.
	#the compiler can only infer variables for you when they appear in the types of arguments that you supply. It's pretty good at type inference.
#the EQ line that comes before is an alternate way to use == where you also supply the type of the other two arguments.
	#It's useful for when the compiler cannot deduce the type of the arguments you supply automatically, like in the cases (A,B)==(A,B) and (|c|c)==(|c|c)

REFLEXIVITY: [A?:U,a:A]a==a,#this is the reflexivity property of equality
SUBSTITUTION:[A?:U,a?:A,b?:A,J:[c:A,a==c]U,q:a==b,J(a,REFLEXIVITY(a))]J(b,q),#this is path induction.

SUBSTITUTE_GARUNTEE:[A?:U,a?:A,J:[c:A,a==c]U,k:J(a,REFLEXIVITY(a))]SUBSTITUTION(|w,y|J(w,y),REFLEXIVITY(a),k) == k,#this is the base case for path induction

'^':         [A?:U,a?:A,b?:A,q:b==a]a==b                     = SUBSTITUTION(|w,_|w==b,q,REFLEXIVITY(b)),#this is the symmetric property of equality. I prove it with path induction.
EQUIVALENCE: [A?:U,B?:U,a:A,q:A==B]B                         = SUBSTITUTION(|w,_|w,q,a),                            #this is a property of equality. I prove it with path induction.
PRESERVATION:[A?:U,B?:U,a?:A,b?:A,f:[A]B,q:a==b]f(a) == f(b) = SUBSTITUTION(|w,_|f(a)==f(w),q,REFLEXIVITY(f(a))),   #this is a property of equality. I prove it with path induction.
'->':        [J?:U,a?:J,b?:J,c?:J,q1:a==b,q2:b==c]a==c       = SUBSTITUTION(|w,_|a==w,q2,q1),          #this is the transitive property of equality. I prove it with path induction.


'!':[A:U]U = [A,u:U]u,#This is negation;the inhabitation of A implies the inhabitation of all things, which is a contradiction.
'!=':[A?:U,a:A,b:A]U = !(a==b),


# Types may be nested and unraveled.
#the following is actually inconsistant because of a technicality and needs to be revised......
|DEC,DEC.POSITIVE,DEC.NEGATIVE|:[T?:U,K:U,a:[K]T,b:[!K]T]{
    dec:T,#<--- This is the definition of a conditional.
    [k:K] dec==a(k),#<--- When the conditional's predicate is true, the conditional's result is equal to its first argument.
    [k:!K]dec==b(k)#<--- When the conditional's predicate is false, the conditional's result is equal to its second argument.
},
|'.'positive,'.'negative|:[K?:U,a?:[K]U,b?:[!K]U,Dec:U = DEC(K,|x|a(x),|x|b(x)),dec:Dec]{
    [pos:K]a(pos) = EQUIVALENCE(dec,Dec.POSITIVE(pos)),
    [neg:!K]b(neg) = EQUIVALENCE(dec,Dec.NEGATIVE(neg))
},

#all the logic defined below need not be referenced in other files. It's all logic about currying and uncurrying.


|AND,['.'acc,'.'accb],[UNION,MEMBER,MEMBERB],AND.equal,FUNC,'.'eval,[MAKEFUNC,FUNCASSURANCE],FUNC.equal|:[A:U,B:[A]U]{#For all (types) and (types derived from the first type)...
    and:U,
    |acc,accb|:[c:and]{#Given an element of the type representing the union...
        acc:A,#you may retrieve an element of the first type.
        B(acc)#you may retrieve an element of the second type as well.
    },
    [a:A,b:B(a)]{#Given elements of each type...
        union:and,#you may construct an element of the type representing the union of two types.
        member:a == acc(union),#accessing the first element from the union gives you back the same element that you used to construct the union.
        memberb:SUBSTITUTION(|w,_|B(w),member,b) == accb(union)#gives you back the second element except a becomes acc(union)
    },
    [au:and,bu:and,q:acc(au)==acc(bu),SUBSTITUTION(|w,_|B(w),q,accb(au))==accb(bu)]au==bu,#this is special; the compiler is going to try to apply this one automatically.

    func:U,
    eval:[func,a:A]B(a),
    [b:[a:A]B(a)] {
        make:func,
        [a:A]eval(make,a) == b(a)
    },
    [af:func,bf:func,[a:A]eval(af,a)==eval(bf,a)]af==bf #this is special
    # ^^^---- apparently this comes from the univalence axiom... but the proof is long and I couldn't follow it.
}





 

# !([a:A]B(a)) == {a:A,!B(a)}







# [A?:U,?B:[A]U,c:{a:A,B(a)}]c == (c.a,c.b)
#  [?A:U,?B:[A]U,b:B,curried:B = |c|b(c),a:A]b(a) == curried(a)

#  [A:U,B:[A]U,a1:A,b1:B(a1),a2:A,b2:B(a2)]
#  EQ({a:A,B(a)},(a1,b1),(a2,b2)) == {c:a1==a2,SUBSTITUTION(|w,_|B(w),b1,c) == b2}
#  [A:U,B:[A]U,b1:[a1:A]B(a1),b2:[a2:A]B(a2)]
#  EQ(B,|a|b1(a),|a|b2(a)) == ([a:A]b1(a) == b2(a))

#  [?J:U,?x:J,?y:J,A:[c:A,x==c]U,B:[c:A,cq:x==c,A(c,cq)]U,q:x==y,a:A(x,REFLEXIVITY(x)),b:B(x,REFLEXIVITY(x),a)]
#  SUBSTITUTION(|w,wq|{a:A(w,wq),B(w,wq,a)},q,(a,b))
#  ==
#  (
#     SUBSTITUTION(|w,wq|A(w,wq),q,a),
#     SUBSTITUTION(
#         |w,wq|B(w,wq,SUBSTITUTION(|w,wq|A(w,wq),wq,a)),
#         q,
#         SUBSTITUTION(
#             |w,_|B(x,REFLEXIVITY(x),w),
#             ^SUBSTITUTE_GARUNTEE(|w,wq|A(w,wq),a),
#             b
#         )
#     )
#  )

#  [?J:U,?x:J,?y:J,A:[c:A,x==c]U,B:[c:A,cq:x==c,A(c,cq)]U,q:x==y,b:[a:A(x,REFLEXIVITY(x))]B(x,REFLEXIVITY(x),a)]
#  SUBSTITUTION(|w,wq|[a:A(w,wq)]B(w,wq,a),q,b)
#  ==
#  (|a|SUBSTITUTION(
#     |w,wq|B(w,wq,SUBSTITUTION(|w,wq|A(w,wq),wq,a)),
#     q,
#     SUBSTITUTION(
#         |w,_|B(x,REFLEXIVITY(x),w),
#         ^SUBSTITUTE_GARUNTEE(|w,wq|A(w,wq),a),
#         b(SUBSTITUTION(A(w,wq),^q,a))
#     )
#  ))



#  eq_combine:[?A:U,?B:[A]U,?a1:A,?b1:B(a1),?a2:A,?b2:B(a2),aq:a1==a2,bq:SUBSTITUTION(|w,wq|B(w),aq,b1)==b2]
#     EQ({a:A,B(a)},(a1,b1),(a2,b2))



#  eq_unnest:[]


#  best way to provide the fact that functions are equal...?

 



#  {asdf} === {asdf}
#  -each row that has no type reference to another row will simply provide the ==.
#  -rows marked as compactible are omitted completely.
#  -rows where the solution is identity is omitted completely.
#  -substitutions over unions are automatically split up.
#  -substitutions over functions are automatically split up.
#  -constant substitutions are automatically eliminated.






#  {a:A,b:P(a),c:K(b)} <-- impossible; will never occur


#  {a:A,b:B,c:K(a,b)} <-- possible; will occur

#  {a:A,b:P(a),c:K(a,b)} <-- possible; will occur

#  a:a1 == a2
#  b:SUBSTITUTION(|w,_|B(w),a,b1) == b2
#  c:




#  {a:A,b:B(a),c:C(a,b)}

#  SUBSTITUTION(|[a,b],_|C(a,b),(a,b),c1)










#  for function and union types: ----> leftmost is topmost

#  K(a,b) are you substituting a or b first? a.

#  SUBSTITUTION(
#     |w,wq|{}

#  )




#  SUBSTITUTION(|w,wq|[A(w,wq)]B(w,wq),q,yo)(SUBSTITUTION(|w,wq|A(w,wq),q,inp))
#  == 
#  SUBSTITUTION( |w,wq|B(w,wq),q,yo(inp) )






# autocast to func when there are insufficient parameters.






# |homomorph_body,HOMOMORPH| := [A:U,B:U]{#univalent foundations but not homotopy type theory; this type theory system does not support subtyping.
#     homomorph_body := {
#         f:[A]B,
#         g:[B]A,
#         gf:[a:A]g(f(a))==a,
#         fg:[b:B]f(g(b))==b
#     },
#     (A==B) == homomorph_body
# },

# uni:[A?:U,B?:U]U = {
#     uni_block:homomorph_body(A==B,homomorph_body(A,B)) = SUBSTITUTION(
#         |w,_|w,
#         HOMOMORPH(HOMOMORPH(A,B),homomorph_body(A==B,homomorph_body(A,B))),
#         HOMOMORPH(A,B)
#     ),
#     eq_implies:[q:A==B]homomorph_body(A,B) = uni_block.f(q),
#     implies_eq:[f:[A]B,g:[B]A,gf:[a:A]g(f(a))==a,fg:[b:B]f(g(b))==b]A==B = uni_block.g((f,g,|a|gf(a),|b|fg(b)))
# }


# UNION_TOOLS: {
#     |distributive_contractability|:[?A:U,?B:[A]U]{
#         [q1:[x:A,y:A]x==y,q2:[z:A,u:B(z),v:B(z)]u==v,c:AND(A,B),d:AND(A,B)]c==d = 
#             AND(A,|a|B(a)).equal(
#                 c,d
#                 q1(c.acc,d.acc),q2(SUBSTITUTION(|w,_|B(w),q1(c.acc,d.acc),c.accb),d.accb)
#             )
#     }
# }

# UNIVALENCE_TOOLS:{
#     split_substitution:[?A:U,?a:A,?b:A,J:[c:A,a==c,d:A,a==d]U,q:a==b,k:J(a,REFLEXIVITY(a),a,REFLEXIVITY(a))]SUBSTITUTION(|w,wq|f(w,wq,w,wq),q,k) ==
#         SUBSTITUTION(
#             |w,wq|f(w,wq,b,q),q,
#             SUBSTITUTION(|w,wq|f(a,REFLEXIVITY(a),w,wq),q,k)
#         ) = 
#         SUBSTITUTION(
#             |y,yq|SUBSTITUTION(|w,wq|f(w,wq,w,wq),yq,k) == 
#                 SUBSTITUTION(
#                     |w,wq|f(w,wq,y,yq),yq,
#                     SUBSTITUTION(|w,wq|f(a,REFLEXIVITY(a),w,wq),yq,k)
#                 ),
#             q,
#             SUBSTITUTE_GARUNTEE(|w,wq|f(w,wq,w,wq),k) ->
#             SUBSTITUTION(
#                 |w,_|k == SUBSTITUTION(|w,wq|f(w,wq,a,REFLEXIVITY(a)),REFLEXIVITY(a),w),
#                 ^SUBSTITUTE_GARUNTEE(|w,wq|f(a,REFLEXIVITY(a),w,wq),k)
#                 ^SUBSTITUTE_GARUNTEE(|w,wq|f(w,wq,a,REFLEXIVITY(a)),k)
#             )
#         ),

#     contractible_fiber:[J:U,j:T,a:{g:J,y:j==g},b:{g:J,y:j==g}]a==b = 
#         SUBSTITUTION(
#             |q,qw|(a.g,a.y) =({g:J,y:j==g})= (q,qw),
#             b.y,
#             SUBSTITUTION(
#                 |q,qw|(q,qw) =({g:J,y:j==g})= (j,REFLEXIVITY(j)),
#                 a.y,
#                 REFLEXIVITY({g:J,y:j==g},(j,REFLEXIVITY(j)))
#             )
#         ),
#     equiv_contract:[?J:U,?T:U,q1:T==J,q2:[a:T,b:T]a==b,a:J,b:J]a==b = 
#         SUBSTITUTION(
#             |w,_|FUNC(w,|a|FUNC(w,|b|a==b)),
#             q1,
#             q2
#         ).eval(a).eval(b)


#     substitute_injective:[?A:U,?a:A,?b:A,f:[c:A,a==c]U,k:f(a,REFLEXIVITY(a)),l:f(a,REFLEXIVITY(a)),q:a==b,g:SUBSTITUTION(|w,wq|f(w,wq),q,k)==SUBSTITUTION(|w,wq|f(w,wq),q,l)]k==l =
#         SUBSTITUTION(
#             |w,wq|FUNC(SUBSTITUTION(|w,wq|f(w,wq),wq,k)==SUBSTITUTION(|w,wq|f(w,wq),wq,l),|_|k==l),
#             q,
#             FUNC(SUBSTITUTION(|w,wq|f(w,wq),wq,k)==SUBSTITUTION(|w,wq|f(w,wq),wq,l),
#                 |y|^SUBSTITUTE_GARUNTEE(|w,wq|f(w,wq),k) -> y -> SUBSTITUTE_GARUNTEE(|w,wq|f(w,wq),l))
#             SUBSTITUTE_GARUNTEE(|w,wq|f(w,wq),k)
#         ).eval(g),






#     nothingpath:[?A:U,?a:A,?b:A,?J:U,k:J,q:a==b]SUBSTITUTION(|_,_|J,q,k) == k = 
#         SUBSTITUTION(
#             |_,wq|SUBSTITUTION(|_,_|J,wq,k) == k,
#             q,
#             SUBSTITUTE_GARUNTEE(A,a,|_,_|J,k)
#         ),
        

#     func_sub_distrib:[
#         ?J:U,?a:J,?b:J,
#         A:[c:A,a==c]U,
#         B:[c:A,a==c]U,
#         q:a==b,
#         yo:FUNC(A(a,REFLEXIVITY(a)),|_|B(a,REFLEXIVITY(a))),
#         inp:A(a,REFLEXIVITY(a))
#     ]
#         SUBSTITUTION(
#             |w,wq|FUNC(A(w,wq),|_|B(w,wq)),q,yo
#         ).eval(SUBSTITUTION(|w,wq|A(w,wq),q,inp)) == SUBSTITUTION(|w,wq|B(w,wq),q,yo.eval(inp)) =
#         ^SUBSTITUTE_GARUNTEE(
#             |w,wq|B(w,wq),
#             SUBSTITUTION(
#                 |w,wq|FUNC(A(w,wq),|_|B(w,wq)),q,yo
#             ).eval(SUBSTITUTION(|w,wq|A(w,wq),q,inp))
#         ) ->
#         SUBSTITUTION(
#             |w,q|SUBSTITUTION(
#                 |w,wq|B(w,wq),
#                 REFLEXIVITY(w),
#                 SUBSTITUTION(
#                     |w,wq|FUNC(A(w,wq),|_|B(w,wq)),WQ,yo
#                 ).eval(SUBSTITUTION(|w,wq|A(w,wq),WQ,inp))
#             ) ==
#             SUBSTITUTION(
#                 |w,wq|B(w,wq),
#                 WQ,
#                 SUBSTITUTION(
#                     |w,wq|FUNC(A(w,wq),|_|B(w,wq)),REFLEXIVITY(a),yo
#                 ).eval(SUBSTITUTION(|w,wq|A(w,wq),REFLEXIVITY(a),inp))
#             ),
#             q,
#             REFLEXIVITY(
#                 SUBSTITUTION(
#                     |w,wq|B(w,wq),
#                     REFLEXIVITY(a),
#                     SUBSTITUTION(
#                         |w,wq|FUNC(A(w,wq),|_|B(w,wq)),REFLEXIVITY(a),yo
#                     ).eval(SUBSTITUTION(|w,wq|A(w,wq),REFLEXIVITY(a),inp))
#                 )
#             )
#         ) ->
#         PRESERVATION(
#             |w|w.eval(SUBSTITUTION(|w,wq|A(w,wq),REFLEXIVITY(a),inp)),
#             SUBSTITUTE_GARUNTEE(|w,wq|FUNC(A(w,wq),|_|B(w,wq)),yo)
#         ) ->
#         PRESERVATION(
#             |w|yo.eval(w),
#             SUBSTITUTE_GARUNTEE(|w,wq|A(w,wq),inp)
#         ),


#     union_sub_distrib_a:[
#         ?J:U,?a:J,?b:J,
#         A:[c:A,a==c]U,
#         B:[c:A,cq:a==c,A(c,cq)]U,
#         q:a==b,
#         isn:AND(A(a,REFLEXIVITY(a)),|c|B(a,REFLEXIVITY(a),c)),
#     ]
#         SUBSTITUTION(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),q,isn).acc == SUBSTITUTION(|w,wq|A(w,wq),q,isn.acc) = 
#         ^SUBSTITUTE_GARUNTEE(
#             |w,wq|A(w,wq),
#             SUBSTITUTION(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),q,isn).acc
#         ) ->
#         SUBSTITUTION(
#             |w,wq|
#             SUBSTITUTION(|w,wq|A(w,wq),REFLEXIVITY(w),SUBSTITUTION(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),wq,isn).acc) ==
#             SUBSTITUTION(|w,wq|A(w,wq),wq,SUBSTITUTION(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),REFLEXIVITY(a),isn).acc),
#             q,
#             REFLEXIVITY(
#                 SUBSTITUTION(|w,wq|A(w,wq),REFLEXIVITY(a),SUBSTITUTION(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),REFLEXIVITY(a),isn).acc)
#             )
#         ) ->
#         PRESERVATION(
#             |y|SUBSTITUTION(|w,wq|A(w,wq),wq,y.acc),
#             SUBSTITUTE_GARUNTEE(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),isn)
#         )



#     substitute_annhialate:[?J:U,?x:J,?y:J,q:x==y,I:[J]U,k:I(x)]
#         SUBSTITUTION(|w,_|I(w),q,SUBSTITUTION(|w,_|I(w),^q,k)) == k = 
#         SUBSTITUTION(
#             |_,wq|SUBSTITUTION(|w,_|I(w),wq,SUBSTITUTION(|w,_|I(w),^wq,k)) == k,
#             q
#             SUBSTITUTION(
#                 |w,_|SUBSTITUTION(|w,_|I(w),REFLEXIVITY(x),w) == k,
#                 SUBSTITUTION(
#                     |w,_|k == SUBSTITUTION(|w,_|I(w),w,k)
#                     ^sub_id_inverse(x),
#                     ^SUBSTITUTE_GARUNTEE(|w,_|I(w),k),
#                 ),
#                 SUBSTITUTE_GARUNTEE(|w,_|I(w),k)
#             )
#         ),







 

# }







#     union_sub_distrib_a:[
#         ?J:U,?a:J,?b:J,
#         A:[c:A,a==c]U,
#         B:[c:A,cq:a==c,A(c,cq)]U,
#         q:a==b,
#         isn:AND(A(a,REFLEXIVITY(a)),|c|B(a,REFLEXIVITY(a),c)),
#     ]
#         SUBSTITUTION(|w,wq|AND(A(w,wq),|c|B(q,wq,c)),q,isn).acc == SUBSTITUTION(|w,wq|A(w,wq),q,isn.acc) = 



#         you need to do better. the full shabang. with the unions, just like function extensionality distribution.










}
