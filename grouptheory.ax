


^ -> :
! :
== != :
=> >> << <= :
+ - :
* :


{
	::'builtin.ax',
# }

# # homomorphism =/= homotopy (isomporphism)
# # 	homomorphism -> specific to group theory structure
# # 	homotopy ->function with a perfect inverse



# [
# 	::'builtin.ax'
# ]{


# #project euler


# # make an structure thats just for releasable memory objects.




	Relation := {
		J:U,
		'=>':[J,J]U,
		'>>':[a:J,b:J] = !(b=>a),
		'<=':[a:J,b:J] = b=>a,
		'<<':[a:J,b:J] = !(a=>b),
		transitive:[a?:J,b?:J,c?:J,a=>b,b=>c]a=>c,
		reflex:[a:J]a=>a
	}
	# ,
	# Equivalence_relation := Relation<
	# 	|J,'=>','>>','<=','<<',transitive|=|J,'==','!=','==','!=','->'|,
	# 	'^':[a?:J,b?:J,a==b]b==a
	# >
	# ,
# 	Connex_relation := Relation<
# 		|J,'=>','<=','<<','>>'|->,
# 		connex:[a?:J,b?:J,a>>b]a=>b,
# 		reflex = |a|DEC(a=>a,|s|s,|s|s(connex(x)))
# 	>,
# 	Complete_relation := Connex_relation<
# 		|J,'=>','<=','<<','>>'|->,
# 		infimum:[
# 			P:[J]U,Pj:={j:J,p:P(j)},
# 			a:J,
# 			b:[x:Pj]x.j=>a,
# 			Pj
# 		]{
# 			inf:J,
# 			under:[x:Pj]x.j=>inf,
# 			over:[al:J,[x:Pj]x.j=>al]al<=inf
# 		},
# 		supremum:[
# 			P:[J]U,Pj:={j:J,p:P(j)},
# 			a:J,
# 			b:[x:Pj]x.j<=a,
# 			pj:Pj,
# 			sup := infimum(|j|[x:Pj]x.j<=j,pj.j,|x|x.p(pj),(a,b))
# 		]{
# 			j:J = sup.inf,
# 			over:[x:Pj]x.j<=sup = sup.over(x.j,|z|z.p(x)),
# 			under:[al:J,bb:[x:J,P(x)]x<=al]al=>sup = sup.under((al,bb))
# 		}
# 	>,
# 	Conditionally_noether_relation := Complete_relation<
# 		|J,'=>','<=','<<','>>'|->,
# 		new_infimum:[
# 			P:[J]U,Pj:={j:J,p:P(j)},
# 			a:J,
# 			b:[Pj]x=>a,
# 			Pj
# 		]{
# 			pj:Pj,
# 			under:[Pj]pj.j=>inf
# 		},
# 		infimum = |P,a,b,pj|(
# 			new_infimum(P,a,b,pj).pj.j,
# 			new_infimum(P,a,b,pj).under,
# 			|al,bou|bou(new_infimum(P,a,b,pj).pj)
# 		)
# 	>,
# 	Noether_relation := Conditionally_noether_relation<
# 		|J,'=>','<=','<<','>>'|->,
# 		noether:[P:[J]U,Pj:={j:J,p:P(j)},Pj]{
# 			l:Pj,
# 			p:[k:Pj]k.j=>l.j
# 		},
# 		connex = |a,b,q|[
# 			P:[x:J]U = OR(x==a,x==b),
# 			Pj:U = {j?:J,p:P(j)},
# 			pa:Pj = P(a).construct(IDENTITY(a)),
# 			pb:Pj = P(b).construct(IDENTITY(b)),
# 			min:= noether(P,a)
# 		]DEC(min.l.j==a,
# 			|s|SUBSTITUTION(|w|a=>w,min.l.p.extract(s),min.p(pa)),
# 			|s|q(SUBSTITUTION(|w|b=>w,s,min.p(pb)))#b=>a
# 		),
# 		new_infimum = |P,a,b,pj|noether(P,pj),
# 		noetherian_induction:[
# 			P:[J]U,
# 			f:[y:J,[z:J,z<<y]P(z)]P(y),
# 			x:J
# 		]P(x) = 
# 			DEC({j:J,p:!P(j)},
# 				|s|[min = noether(|j|!P(j),s)]min.l.p(f(min.l.j,|k,p|DEC(P(k),|h|h,|h|p(min.p((k,h)),P(k))))),#contradiction
# 				|s|negate_union(s,x)
# 			),
# 		noetherian_recursion:[
# 			P:[J]U,
# 			f:[y:J,[z:J,z<<y]P(z)]P(y),
# 		]{
# 			r?:[x:J]P(x),
# 			pred:[x:J]r(x) == f(x,|z,_|r(z))
# 		} = |u|noetherian_induction(
# 				|j|{
# 					r?:[x:J]P(x),
# 					pred:[x:J,q:x<=j]r(x) == f(x,|z,_|r(z))
# 				},
# 				|j,R||x,q|PRESERVATION(
# 					A=[z:J,z<<j]P(z),
# 					|w|f(x,|z,q2|w(z,DEC(z=>j|s|q2(transitive(s,q),z<<j)|s|s))),
# 					|z,q3|R(z,q3).pred(z,connex(q3))
# 				),
# 				u
# 			).pred(u,reflex(u))
# 	>,
# 	Dual_conditionally_noetherian_relation:Conditionally_noether_relation<
# 		|J,'=>','<=',transitive,reflex|->
# 		converse:Conditionally_noether_relation<J=J,'=>'='<=',
# 			transitive=|a,b,c,q1,q2|transitive(q2,q1),
# 			reflex=|a|reflex(a)
# 		>
# 	>,
# 	Truncating_noetherian_relation:Noether_relation<
# 		|J,'=>','<=',transitive,reflex|->
# 		converse:Conditionally_noether_relation<J=J,'=>'='<=',
# 			transitive=|a,b,c,q1,q2|transitive(q2,q1),
# 			reflex=|a|reflex(a)
# 		>
# 	>,
# 	Quasifinite_relation:Noether_relation<
# 		|J,'=>','<=',transitive,reflex|->
# 		converse:Noether_relation<J=J,'=>'='<=',
# 			transitive=|a,b,c,q1,q2|transitive(q2,q1),
# 			reflex=|a|reflex(a)
# 		>
# 	>,




# 	relation_exhibits_antisymmetry

# 	ordered group:
# 		relation exhibits antisymmetry with the given equivalence relation.
# 		relation is transitive forward and backward with the equivalence relation.
# 		relation is translation invariant.

# 	ordered ring:
# 		relation exhibits antisymmetry with the given equivalence relation.
# 		relation is transitive forward and backward with the equivalence relation.
# 		relation is translation invariant. (but only with positive translations)
























# 	Semigroup := {
# 		J:U,
# 		equal_core:Equivalence_relation<J=J>,
# 		'==':=equal_core.'==',
# 		'!=':=equal_core.'!=',
# 		'->':=equal_core.'->',
# 		'^':=equal_core.'^',

# 		0:J,
# 		'+':[l:J,r:J]J,

# 		PRESERVATION_radd:[a?:J,b?:J,a==b,c:J]a+c == b+c,
# 		PRESERVATION_ladd:[a?:J,b?:J,c:J,a==b]c+a == c+b,
# 		PRESERVATION:=PRESERVATION_ladd,
# 		PRESERVATION:=PRESERVATION_radd,

# 		ASSOCIATIVE:[a:J,b:J,c:J](a+b)+c == a+(b+c),
# 		R_IDENTITY:[a:J]a+0==a,
# 		L_IDENTITY:[a:J]0+a==a
# 	},
# 	Group := Semigroup<
# 		|J,0,'+','==',ASSOCIATIVE,R_IDENTITY,'==','!=','->','^',PRESERVATION,PRESERVATION|->,
# 		'-':[j:J]J,
# 		'-':[a:J,b:J]J = a+(-b),

# 		PRESERVATION_inv:[a?:J,b?:J,a==b]-a == -b,
# 		PRESERVATION_inv:[a?:J,b?:J,q:a==b,c:J]-a+c == -b+c = PRESERVATION(PRESERVATION_inv(q),c),
# 		PRESERVATION_inv:[a?:J,b?:J,c:J,q:a==b] c-a ==  c-b = PRESERVATION(c,PRESERVATION_inv(q)),

# 		A_IDENTITY:     [a:J]a-a==0,
# 		assoc_eliminate:[a:J,b:J](a+b)-b == a =
# 			ASSOCIATIVE(a,b,-b) ->
# 			PRESERVATION(A_IDENTITY(b),g) ->#a+0 == a+(b-b)
# 			R_IDENTITY(a),#a+0=a
# 		elim:[b?:J,a?:J,q:a+b == b]a == 0 =
# 			^assoc_eliminate(a,b) ->
# 			PRESERVATION_inv(q,-b) ->
# 			A_IDENTITY(b),
# 		elim:[a?:J,b?:J,c?:J,q:a+b == c+b]a == c = 
# 			^assoc_eliminate(a,b) ->
# 			PRESERVATION_inv(q,-b) ->
# 			assoc_eliminate(c,b),
# 		B_IDENTITY:     [a:J]-a+a==0 = elim(assoc_eliminate(-a,a)),
# 		assoc_eliminate_rev:[a:J,b:J](a-b)+b == a =
# 			ASSOCIATIVE(a,-b,b) ->
# 			PRESERVATION(a,B_IDENTITY(b)) ->#a+0 == a+(b-b)
# 			R_IDENTITY(a),#a+0=a
# 		L_IDENTITY =
# 			PRESERVATION(^A_IDENTITY(a),a) ->#(a-a)+a
# 			assoc_eliminate_rev(a,a),
# 	    nzero_eq_zero: -0 == 0 = elim(L_IDENTITY(0)),
#         negnegative:[a:J] -(-a) == a = 
# 	        elim(#a-a == -(-a)-a
# 	            A_IDENTITY(a)->#a-a == 0(a.l)
# 	            ^B_IDENTITY(-a)#0(a.l) == -(-a)-a
# 	        ),
# 	    neg_distributes:[a:J,b:J] -(a+b) == -b-a =
# 	    	elim(
# 		    	B_IDENTITY(a+b) -> #-(a+b)+(a+b) == 0(b.r)
# 		    	^B_IDENTITY(b) ->
# 		    	PRESERVATION(-b,
# 		    		^L_IDENTITY(b) ->
# 			    	PRESERVATION(
# 			    		^B_IDENTITY(a),
# 			    		b
# 			    	) ->
# 			    	ASSOCIATIVE(-a,a,b)
# 		    	) ->#-b+(-a+(a+b))
# 		    	^ASSOCIATIVE(-b,-a,a+b)#(-b-a)+(a+b)
# 	    	)
# 	>,
# 	Abelian_group := group<
# 		|J,'+','==','!=','->','^',PRESERVATION_radd|->,
# 		COMMUTATIVE:[a:J,b:J]a+b==b+a,
# 		PRESERVATION_ladd = |a,b,c,q|COMMUTATIVE(c,a) -> PRESERVATION_radd(q,c) -> COMMUTATIVE(b,c)
# 	>,
# 	Ring := {
# 		J:U,
# 		equal_core:Equivalence_relation<J=J>,
# 		'==':=equal_core.'==',
# 		'!=':=equal_core.'!=',
# 		'->':=equal_core.'->',
# 		'^':=equal_core.'^',
# 		0:J,
# 		1:J,
# 		q:0 != 1,
# 		'+':[J,J]J,
# 		'-':[J]J,
# 		add:abelian_group<equal_core=equal_core,J=J,0=0,'-'='-','+'='+'>,
# 		'-':[a:J,b:J]J = a+(-b),
# 		'*':[J,J]J,
# 		DISTRIBUTIVE:[a:J,b:J,c:J]a*(b+c) == a*b+a*c,
# 		mult:semigroup<equal_core=equal_core,J=J,0=1,'+'='*'>,
# 		times_zero_is_zero:[a:J]a*0 == 0 = 
# 			add.elim(
# 				^DISTRIBUTIVE(a,0,0) ->#a*0+a*0 == a*(0+0)
# 				mult.PRESERVATION(add.R_IDENTITY(0),r)#a*(0+0) == a*0
# 			),
# 	},
# 	Commutative_ring := Ring<
# 		|mult,'*',1|->,
# 		mult_commutative:[a:J,b:J]a*b==b*a,
# 		mult.PRESERVATION_ladd = |a,b,q,c|mult_commutative(c,a) -> mult.PRESERVATION_radd(q,c) -> mult_commutative(b,c),
# 		mult.L_IDENTITY = |a|mult_commutative(1,a) -> mult.R_IDENTITY(a)
# 	>,
# 	Field := Ring<
# 		|J,0,1,q,'+','-','-','*',add,DISTRIBUTIVE,times_zero_is_zero,equal_core|->,
# 		MINVERSE: [j:J,j!=0]J,
# 		MULTIPLY_R_IDENTITY: [a:J]a*1==a,
# 		MULTIPLY_A_IDENTITY: [a:J,g:a!=0]a*MINVERSE(a,g) == 1,
# 		MULTIPLY_COMMUTATIVE:[a:J,b:J]a*b==b*a,
# 		MULTIPLY_ASSOCIATIVE:[a:J,b:J,c:J](a*b)*c == a*(b*c),
# 		mult:abelian_group<
# 			|PRESERVATION,PRESERVATION|->,
# 			equal_core=equal_core,
# 			J={j:J,i!:j!=0},
# 			0=(1,q),
# 			'+'=|[a,ag],[b,bg]|(
# 				DEC(a*b==0,
# 					|s|a(
# 						^MULTIPLY_R_IDENTITY(a)->#a == a*1
# 						PRESERVATION(a,^MULTIPLY_A_IDENTITY(b,bg)) -> #a*1 == a*(b/b)
# 						^MULTIPLY_ASSOCIATIVE(a,b,MINVERSE(b,bg)) ->#a*(b/b) == (a*b)/b
# 						PRESERVATION(s,MINVERSE(b,bg)) -> #(a*b)/b == 0/b
# 						MULTIPLY_COMMUTATIVE(0,MINVERSE(b,bg)) ->#0/b == /b*0
# 						times_zero_is_zero(MINVERSE(b,bg)),#/b*0 == 0
# 						a*b!=0
# 					),
# 					|s|s
# 				)
# 			),
# 			'-'=|[a,g]|(
# 				MINVERSE(a,ag),
# 				DEC(MINVERSE(a,ag) == 0,
# 					|s|q(
# 						^times_zero_is_zero(a) -> #a*0=0
# 						PRESERVATION(a,^s) ->#a*1/a=a*0
# 						MULTIPLY_A_IDENTITY(a,s),#1=a*1/a
# 						MINVERSE(a,ag) != 0
# 					),
# 					|s|s
# 				)
# 			),
# 			COMMUTATIVE=|[a,ag],[b,bg]|MULTIPLY_COMMUTATIVE(a,b),
# 			ASSOCIATIVE=|[a,ag],[b,bg],[c,cg]|MULTIPLY_ASSOCIATIVE(a,b,c),
# 			A_IDENTITY=|[a,ag]|MULTIPLY_A_IDENTITY(a,ag),
# 			R_IDENTITY=|[a,ag]|MULTIPLY_R_IDENTITY(a)
# 		>,
# 		mult = mult
# 	},





















# 	Relation_bridge:= {
# 		J:U,
# 		equal_core:Equivalence_relation<J=J>,
# 		'==':=equal_core.'==',
# 		'!=':=equal_core.'!=',
# 		'->':=equal_core.'->',
# 		'^':=equal_core.'^',

# 		core:Semigroup<J=J,equal_core=equal_core>,
# 		'+':=core.'+',
# 		relation:Relation<J=J>,
# 		'=>':=relation.'=>',
# 		'<=':=relation.'<=',
# 		'<<':=relation.'<<',
# 		'>>':=relation.'>>',


# 		antisymmetry:[a?:J,b?:J,a=>b,a<=b]a==b,
# 		translation:[a?:J,b?:J,c?:J,a=>b]a+c=>b+c,

# 		PRESERVATION_eq_l: [a?:J,b?:J,c?:J,q1:a=>b,q2:b==c]a=>c,
# 		PRESERVATION_eq_r: [a?:J,b?:J,c?:J,q1:a==b,q2:b=>c]a=>c,
# 		PRESERVATION_neq_l:[a?:J,b?:J,c?:J,q1:a>>b,q2:b==c]a>>c = DEC(a<=c,|s|q1(PRESERVATION_eq_r(^q2,s)),|s|s),
# 		PRESERVATION_neq_r:[a?:J,b?:J,c?:J,q1:a==b,q2:b>>c]a>>c = DEC(a<=c,|s|q2(PRESERVATION_eq_r(s,^q1)),|s|s)
# 	},

# 	Ring_relation_bridge := Relation_bridge<
# 		core:Ring,
# 		core=core,
# 		scaling:[a?:J,b?:J,c?:J,a=>b,c=>0]a*c=>b*c
# 	>



















# 	Semilattice := {
# 		J:U,
# 		equal_core:Equivalence_relation<J=J>,
# 		'==':=equal_core.'==',
# 		'!=':=equal_core.'!=',
# 		'->':=equal_core.'->',
# 		'^':=equal_core.'^',
# 		'*':[J,J]J,
# 		ASSOCIATIVE:[a:J,b:J,c:J](a*b)*c == a*(b*c),
# 		COMMUTATIVE:[a:J,b:J]a*b == b*a,
# 		INDEPOTENT: [a:J]a*a == a,
# 		PRESERVATION:[a?:J,b?:J,a==b,c:J]a+c == b+c,
# 		PRESERVATION:[a?:J,b?:J,c:J,q:a==b]c+a == c+b = COMMUTATIVE(c,a) -> PRESERVATION(q,c) -> COMMUTATIVE(b,c)
# 	}
# 	Bounded_semilattice := Semilattice<
# 		|J,'*',COMMUTATIVE|->,
# 		0:J,
# 		R_IDENTITY:[a:J]a*0 == a,
# 		L_IDENTITY:[a:J]0*a == a = COMMUTATIVE(0,a) -> R_IDENTITY(a)
# 	>,
# 	Lattice := {
# 		J:U,
# 		equal_core:Equivalence_relation<J=J>,
# 		'==':=equal_core.'==',
# 		'!=':=equal_core.'!=',
# 		'->':=equal_core.'->',
# 		'^':=equal_core.'^',
# 		'&&':[J,J]J,
# 		'$$':[J,J]J,
# 		absorption_join:[a:J,b:J]a&&(a$$b) == a,
# 		absorption_meet:[a:J,b:J]a$$(a&&b) == a,
# 		join:Semilattice<J=J,equal_core=equal_core,'*'='&&',
# 			|PRESERVATION|->,
# 			INDEPOTENT=|a|PRESERVATION(a,
# 				^absorption_meet(a,a)
# 			) -> absorption_join(a,a&&a)#a&&(a$$(a&&a)) == a
# 		>,
# 		meet:Semilattice<J=J,equal_core=equal_core,'*'='$$',
# 			|PRESERVATION|->,
# 			INDEPOTENT=|a|PRESERVATION(a,
# 				^absorption_join(a,a)
# 			) -> absorption_meet(a,a$$a)#a&&(a$$(a&&a)) == a
# 		>
# 	},
# 	Bounded_lattice := Lattice<
# 		|J,'&&','$$',join,meet|->,
# 		T:J,
# 		F:J,
# 		join:Bounded_semilattice<0=T>,
# 		join = join,
# 		meet:Bounded_semilattice<0=F>,
# 		meet = meet,
# 		l_join_domination:[a:J]F&&a == F =
# 			join.PRESERVATION(F,
# 				^meet.L_IDENTITY(a),
# 			) -> absorption_join(F,a),
# 		l_meet_domination:[a:J]T$$a == T =
# 			meet.PRESERVATION(T,
# 				^join.L_IDENTITY(a),
# 			) -> absorption_meet(T,a),
# 		r_join_domination:[a:J]a&&F == F = join.COMMUTATIVE(a,F)->l_join_domination(a), 
# 		r_meet_domination:[a:J]a$$T == T = meet.COMMUTATIVE(a,T)->l_meet_domination(a)
# 	>,
# 	Complemented_lattice := Bounded_lattice<
# 		|J,T,F'&&','$$',join,meet|->,
# 		'!!'[J]J,
# 		complement_join:[a:J]a && !!a == F,
# 		complement_meet:[a:J]a $$ !!a == T
# 	>,
# 	Distributive_lattice := Complemented_lattice<#bounded_lattice but also distributive and complement.
# 		|J,'&&','$$','!!'|->,

# 		distributive_join:[a:J,b:J,c:J]a&&(b$$c) == (a&&b)$$(a&&c),
# 		distributive_meet:[a:J,b:J,c:J]a$$(b&&c) == (a$$b)&&(a$$c),

# 		de_morgan_join:[a:J,b:J]!!(a&&b) == (!!a)$$(!!b) = LKJHLKJHLKJHLKJ,
# 		de_morgan_meet:[a:J,b:J]!!(a$$b) == (!!a)&&(!!b) = KJHLJHLKJHLK

# 	>,#boolean algebra is a complemented distributive lattice.


# 	#abelian + semigroup = ring
# 	#abelian + abelian   = field
# 	#abelian + ring      = module
# 	#abelian + field     = vector space

# 	#distributive, associative, identity.
# 	# module := {
# 	# 	abelian + ring

# 	# },
# 	# vector_space := {
# 	# 	abelian + field

# 	# },


























# ordered groups



# exponentation forms module?

# ints are ring + the group of multiplication. (does distribute...)
# negative negative problem...



# horizontal bound: c
# constant vertical bound >0 (each)
# each must decrease.



# x*x == 2, x>>0

# x == 2/x

# decreasing but always >> 0...

# 2/x >> x   iff   2 >> x


# [n<<a]n<<=a-1



# c:J,
# l:J
# [e:J,e>>0]{
# 	s:J,
# 	s>>0,
# 	[x:J,abs(x-c)<<s]abs(f(x)-l)<<e
# }



# positive values closed under addition and multiplication






}