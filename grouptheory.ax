

^ ->        :
!           :
== !=       :
=> >> << <= :
+ -         :
*           :

# pos,y,P



{
	::'builtin.ax',
# # homomorphism =/= homotopy (isomporphism)
# # 	homomorphism -> specific to group theory structure
# # 	homotopy ->function with a perfect inverse

# #project euler

# # make an structure thats just for releasable memory objects.
	Relation := {
		J:U,
		'=>':[J,J]U,
		'>>':[a:J,b:J] = !(b=>a),
		'<=':[a:J,b:J] = b=>a,
		'<<':[a:J,b:J] = !(a=>b),
		transitive:[a?:J,b?:J,c?:J,a=>b,b=>c]a=>c,
		transitive:[a?:J,b?:J,c?:J,q1:a<=b,q2:b<=c]a<=c = transitive(q2,q1),
		sharptransitive:[a?:J,b?:J,c?:J,q1:a=>b,q2:b>>c]a>>c = DEC(c=>a,|s|q2(transitive(s,q1),a>>c),|s|s),
		sharptransitive:[a?:J,b?:J,c?:J,q1:a>>b,q2:b=>c]a>>c = DEC(c=>a,|s|q1(transitive(s,q2),a>>c),|s|s),
		sharptransitive:[a?:J,b?:J,c?:J,q1:a=>b,q2:b>>c]a>>c = DEC(c=>a,|s|q2(transitive(s,q1),a>>c),|s|s),
		sharptransitive:[a?:J,b?:J,c?:J,q1:a>>b,q2:b=>c]a>>c = DEC(c=>a,|s|q1(transitive(s,q2),a>>c),|s|s),
		reflex:[a:J]a=>a
	},
	Equivalence_relation := Relation<
		|J,'=>','>>','<=','<<',transitive|=|J,'==','!=','==','!=','->'|,#notation changes for equivalence relation...
		'^':[a?:J,b?:J,a==b]b==a#symmetric property
	>,
	Connex_relation := Relation<
		|J,'=>','<=','<<','>>',sharptransitive|,
		connex:[a?:J,b?:J,a>>b]a=>b,
		sharptransitive:[a?:J,b?:J,c?:J,q1:a>>b,q2:b>>c]a>>c = DEC(c=>a,|s|q2(connex(sharptransitive(s,q1)),a>>c),|s|s),
		sharptransitive:[a?:J,b?:J,c?:J,q2:b>>c,q1:a>>b]a>>c = DEC(c=>a,|s|q2(connex(sharptransitive(s,q1)),a>>c),|s|s),
		reflex = |a|DEC(a=>a,|s|s,|s|s(connex(s),a=>a))
		#reflexivity can be implied from connexity so might as well include the proof.
		#this way, when a user is supplying a connex relation, they don't need to prove reflexivity.
		# make sure length of parameters exactly matches the length of the argument piece you break off in the end.
		# make sure ? arguments are ignored on verified structures.
	>,
	Complete_relation := Connex_relation<
		|J,'=>','<=','<<','>>'|,
		infimum:[
			P:[J]U,Pj:={j:J,p:P(j)},
			a:J,
			b:[x:Pj]x.j=>a,
			Pj
		]{
			inf:J,
			under:[x:Pj]x.j=>inf,
			over:[al:J,[x:Pj]x.j=>al]al<=inf
		},
		supremum:[
			P:[J]U,Pj:={j:J,p:P(j)},
			a:J,
			b:[x:Pj]x.j<=a,
			pj:Pj,
			sup := infimum(|j|[x:Pj]x.j<=j,pj.j,|x|x.p(pj),(a,b))
		]{
			j:J = sup.inf,
			over:[x:Pj]x.j<=sup.inf = sup.over(x.j,|z|z.p(x)),
			under:[al:J,b:[x:Pj]x.j<=al]al=>sup.inf = sup.under((al,b))
		}
	>,
	Conditionally_noether_relation := Complete_relation<
		|J,'=>','<=','<<','>>'|,
		new_infimum:[
			P:[J]U,Pj:={j:J,p:P(j)},
			a:J,
			b:[x:Pj]x.j=>a,
			Pj
		]{
			inf:Pj,
			under:[x:Pj]x.j=>inf.j
		},
		infimum = |P,a,b,pj|(
			new_infimum(P,a,b,pj).inf.j,
			new_infimum(P,a,b,pj).under,
			|al,bou|bou(new_infimum(P,a,b,pj).inf)
		)
	>,
	Noether_relation := Conditionally_noether_relation<
		|J,'=>','<=','<<','>>',reflex,transitive,sharptransitive,connex|,
		noether:[P:[J]U,Pj:={j:J,p:P(j)},Pj]{
			l:Pj,
			p:[k:Pj]k.j=>l.j
		},
		noetherian_induction:[
			P:[J]U,
			f:[y:J,[z:J,z<<y]P(z)]P(y),
			x:J
		]P(x) =
			DEC({j:J,p:!P(j)},
				|s|[min := noether(|j|!P(j),s)]min.l.p(f(min.l.j,|k,p|DEC(P(k),|h|h,|h|p(min.p((k,h)),P(k)))),P(x)),#proof by contradiction
				|s|negate_union(s,x)
			),
		noetherian_recursion:[
			P:[J]U,
			f:[y:J,[z:J,z<<y]P(z)]P(y)
		]{
			r:[x:J]P(x),
			pred:[x:J]r(x) == f(x,|z,_|r(z))#provide a call context for ().
		} = (
			pred=|u|noetherian_induction(
				|j|{
					r:[x:J,x<<j]P(x),
					pred:[x:J,xq:x<<j]r(x,xq) == f(x,|z,zq|r(z,sharptransitive(xq,zq)))
				},
				|j,R|[
					R_collapse_pred:[
						aj:J,qa:aj<<j,
						bj:J,qb:bj<<j,
						Ra:=R(aj,qa),
						Rb:=R(bj,qb),
						R_comp_pack:={
							x:J,
							qxa:x<<aj,
							qxb:x<<bj,
							pred := Ra.r(x,qxa) == Rb.r(x,qxb)
						},
						rc:R_comp_pack
					] rc.pred =
					noetherian_induction(
						|j|[rc:R_comp_pack<j>]rc.pred,
						|j,R2,rc|
						Ra.pred(rc.x,rc.qxa) ->#f(x,|z,zq|Ra.r(z,sharptransitive(xq,zq)))
						PRESERVATION(
							f(rc.x),
							|z,qz|R2(z,qz,(sharptransitive(rc.qxa,qz),sharptransitive(rc.qxb,qz))),
							A=[z:J,z<<rc.x]P(z),
							# a=|t,tq|f(t,|z,zq|Ra.r(z,sharptransitive(rc.qxa,sharptransitive(tq,zq)))),
							# b=|t,tq|f(t,|z,zq|Rb.r(z,sharptransitive(rc.qxb,sharptransitive(tq,zq))))
							a=|z,zq|Ra.r(z,sharptransitive(rc.qxa,zq)),
							b=|z,zq|Rb.r(z,sharptransitive(rc.qxb,zq))
						) ->
						^Rb.pred(rc.x,rc.qxb),
						rc.x
					)(rc)
				](
					r=|x,xq|f(x,|z,zq|R(x,xq).r(z,zq)),#R() needs to be called on the subordinate stuff, not just x- it needs to be part of r.
					pred=|x,xq|PRESERVATION(
						f(x),
						|t,tq|R(x,xq).pred(t,tq) ->#this gives you x,xq every time- that's just how the dereferencing works.
							PRESERVATION(
								f(x),
								|g,gq|R_collapse_pred(x,xq,t,sharptransitive(xq,tq),(g,gq,tq)),
								A = [z:J,z<<x]P(z)
							),
						A = [z:J,z<<x]P(z),
						a = |z,zq|R(x,xq).r(z,zq),
						b = |z,zq|f(z,|l,lq|R(x,xq).r(l,sharptransitive(zq,lq)))
					)
				),
					# (
					# 	r=|x,xq|f(x,|z,zq|R(z,sharptransitive(xq,zq)).r(z,reflex(z))),#
					# 	pred=PRESERVATION(
					# 		|w|f(j,|z,zq|w(z,zq)),#function extensionality is built in. / make sure context always represents the names correctly.
					# 		|z,q3|R(z,q3).pred,
					# 		A = [z:J,z<<j]P(z)
					# 		# a = |z,qz|R(z,qz).r(z),
					# 		# b = |z,qz|f(z,|l,_|R(z,qz).r(l))
					# 	)
					# ),
				u
			).pred(u)
		),



		# noetherian_recursion:[
		# 	P:[J]U,
		# 	f:[y:J,[z:J,z<<y]P(z)]P(y)
		# ]{
		# 	r:[x:J]P(x),
		# 	pred:[x:J]r(x) == f(x,|z,_|r(z))#provide a call context for ().
		# } = 
		# (
		# 	pred=|u|noetherian_induction(
		# 		|j|{
		# 			r:[x:J,x<=j]P(x),
		# 			pred:r(j,reflex(j)) == f(j,|z,zq|r(z,connex(zq)))
		# 		},
		# 		|j,R|
		# 			(
		# 				r=|x,xq|f(x,|z,zq|R(z,sharptransitive(xq,zq)).r(z,reflex(z))),
		# 				pred=PRESERVATION(
		# 					|w|f(j,|z,zq|w(z,zq)),#function extensionality is built in. / make sure context always represents the names correctly.
		# 					|z,q3|R(z,q3).pred,
		# 					A = [z:J,z<<j]P(z)
		# 					# a = |z,qz|R(z,qz).r(z),
		# 					# b = |z,qz|f(z,|l,_|R(z,qz).r(l))
		# 				)
		# 			),
		# 			# (
		# 			# 	r=|x,xq|f(x,|z,zq|R(z,sharptransitive(xq,zq)).r(z,reflex(z))),#
		# 			# 	pred=PRESERVATION(
		# 			# 		|w|f(j,|z,zq|w(z,zq)),#function extensionality is built in. / make sure context always represents the names correctly.
		# 			# 		|z,q3|R(z,q3).pred,
		# 			# 		A = [z:J,z<<j]P(z)
		# 			# 		# a = |z,qz|R(z,qz).r(z),
		# 			# 		# b = |z,qz|f(z,|l,_|R(z,qz).r(l))
		# 			# 	)
		# 			# ),
		# 		u
		# 	).pred(u)
		# ),


		connex = |a,b,q|[
			P:[x:J]U = OR(x==a,x==b),
			Pj:U = {j?:J,p:P(j)},
			pa:Pj = P(a).construct(IDENTITY(a)),
			pb:Pj = P(b).construct(IDENTITY(b)),
			min:= noether(P,a)
		]DEC(min.l.j==a,
			|s|SUBSTITUTION(|w|a=>w,min.l.p.extract(s),min.p(pa)),
			|s|q(SUBSTITUTION(|w|b=>w,s,min.p(pb)))#b=>a
		),
		new_infimum = |P,a,b,pj|noether(P,pj)
	>
	# ,








	# Inductive_Type

# 	Dual_conditionally_noetherian_relation:Conditionally_noether_relation<
# 		|J,'=>','<=',transitive,reflex|->
# 		converse:Conditionally_noether_relation<J=J,'=>'='<=',
# 			transitive=|a,b,c,q1,q2|transitive(q2,q1),
# 			reflex=|a|reflex(a)
# 		>
# 	>
# ,
# 	Truncating_noetherian_relation:Noether_relation<
# 		|J,'=>','<=',transitive,reflex|->
# 		converse:Conditionally_noether_relation<J=J,'=>'='<=',
# 			transitive=|a,b,c,q1,q2|transitive(q2,q1),
# 			reflex=|a|reflex(a)
# 		>
# 	>,
# 	Quasifinite_relation:Noether_relation<
# 		|J,'=>','<=',transitive,reflex|->
# 		converse:Noether_relation<J=J,'=>'='<=',
# 			transitive=|a,b,c,q1,q2|transitive(q2,q1),
# 			reflex=|a|reflex(a)
# 		>
# 	>,



# 	relation_exhibits_antisymmetry

# 	ordered group:
# 		relation exhibits antisymmetry with the given equivalence relation.
# 		relation is transitive forward and backward with the equivalence relation.
# 		relation is translation invariant.

# 	ordered ring:
# 		relation exhibits antisymmetry with the given equivalence relation.
# 		relation is transitive forward and backward with the equivalence relation.
# 		relation is translation invariant. (but only with positive translations)





# 	Semigroup := {
# 		J:U,
# 		equal_core:Equivalence_relation<J=J>,
# 		'==':=equal_core.'==',
# 		'!=':=equal_core.'!=',
# 		'->':=equal_core.'->',
# 		'^':=equal_core.'^',

# 		0:J,
# 		'+':[l:J,r:J]J,

# 		PRESERVATION_radd:[a?:J,b?:J,a==b,c:J]a+c == b+c,
# 		PRESERVATION_ladd:[a?:J,b?:J,c:J,a==b]c+a == c+b,
# 		PRESERVATION:=PRESERVATION_ladd,
# 		PRESERVATION:=PRESERVATION_radd,

# 		ASSOCIATIVE:[a:J,b:J,c:J](a+b)+c == a+(b+c),
# 		R_IDENTITY:[a:J]a+0==a,
# 		L_IDENTITY:[a:J]0+a==a
# 	},
# 	Group := Semigroup<
# 		|J,0,'+','==',ASSOCIATIVE,R_IDENTITY,'==','!=','->','^',PRESERVATION,PRESERVATION|->,
# 		'-':[j:J]J,
# 		'-':[a:J,b:J]J = a+(-b),

# 		PRESERVATION_inv:[a?:J,b?:J,a==b]-a == -b,
# 		PRESERVATION_inv:[a?:J,b?:J,q:a==b,c:J]-a+c == -b+c = PRESERVATION(PRESERVATION_inv(q),c),
# 		PRESERVATION_inv:[a?:J,b?:J,c:J,q:a==b] c-a ==  c-b = PRESERVATION(c,PRESERVATION_inv(q)),

# 		A_IDENTITY:     [a:J]a-a==0,
# 		assoc_eliminate:[a:J,b:J](a+b)-b == a =
# 			ASSOCIATIVE(a,b,-b) ->
# 			PRESERVATION(A_IDENTITY(b),g) ->#a+0 == a+(b-b)
# 			R_IDENTITY(a),#a+0=a
# 		elim:[b?:J,a?:J,q:a+b == b]a == 0 =
# 			^assoc_eliminate(a,b) ->
# 			PRESERVATION_inv(q,-b) ->
# 			A_IDENTITY(b),
# 		elim:[a?:J,b?:J,c?:J,q:a+b == c+b]a == c = 
# 			^assoc_eliminate(a,b) ->
# 			PRESERVATION_inv(q,-b) ->
# 			assoc_eliminate(c,b),
# 		B_IDENTITY:     [a:J]-a+a==0 = elim(assoc_eliminate(-a,a)),
# 		assoc_eliminate_rev:[a:J,b:J](a-b)+b == a =
# 			ASSOCIATIVE(a,-b,b) ->
# 			PRESERVATION(a,B_IDENTITY(b)) ->#a+0 == a+(b-b)
# 			R_IDENTITY(a),#a+0=a
# 		L_IDENTITY =
# 			PRESERVATION(^A_IDENTITY(a),a) ->#(a-a)+a
# 			assoc_eliminate_rev(a,a),
# 	    nzero_eq_zero: -0 == 0 = elim(L_IDENTITY(0)),
#         negnegative:[a:J] -(-a) == a = 
# 	        elim(#a-a == -(-a)-a
# 	            A_IDENTITY(a)->#a-a == 0(a.l)
# 	            ^B_IDENTITY(-a)#0(a.l) == -(-a)-a
# 	        ),
# 	    neg_distributes:[a:J,b:J] -(a+b) == -b-a =
# 	    	elim(
# 		    	B_IDENTITY(a+b) -> #-(a+b)+(a+b) == 0(b.r)
# 		    	^B_IDENTITY(b) ->
# 		    	PRESERVATION(-b,
# 		    		^L_IDENTITY(b) ->
# 			    	PRESERVATION(
# 			    		^B_IDENTITY(a),
# 			    		b
# 			    	) ->
# 			    	ASSOCIATIVE(-a,a,b)
# 		    	) ->#-b+(-a+(a+b))
# 		    	^ASSOCIATIVE(-b,-a,a+b)#(-b-a)+(a+b)
# 	    	)
# 	>,
# 	Abelian_group := group<
# 		|J,'+','==','!=','->','^',PRESERVATION_radd|->,
# 		COMMUTATIVE:[a:J,b:J]a+b==b+a,
# 		PRESERVATION_ladd = |a,b,c,q|COMMUTATIVE(c,a) -> PRESERVATION_radd(q,c) -> COMMUTATIVE(b,c)
# 	>,
# 	Ring := {
# 		J:U,
# 		equal_core:Equivalence_relation<J=J>,
# 		'==':=equal_core.'==',
# 		'!=':=equal_core.'!=',
# 		'->':=equal_core.'->',
# 		'^':=equal_core.'^',
# 		0:J,
# 		1:J,
# 		q:0 != 1,
# 		'+':[J,J]J,
# 		'-':[J]J,
# 		add:abelian_group<equal_core=equal_core,J=J,0=0,'-'='-','+'='+'>,
# 		'-':[a:J,b:J]J = a+(-b),
# 		'*':[J,J]J,
# 		DISTRIBUTIVE:[a:J,b:J,c:J]a*(b+c) == a*b+a*c,
# 		mult:semigroup<equal_core=equal_core,J=J,0=1,'+'='*'>,
# 		times_zero_is_zero:[a:J]a*0 == 0 = 
# 			add.elim(
# 				^DISTRIBUTIVE(a,0,0) ->#a*0+a*0 == a*(0+0)
# 				mult.PRESERVATION(add.R_IDENTITY(0),r)#a*(0+0) == a*0
# 			),
# 	},
# 	Commutative_ring := Ring<
# 		|mult,'*',1|->,
# 		mult_commutative:[a:J,b:J]a*b==b*a,
# 		mult.PRESERVATION_ladd = |a,b,q,c|mult_commutative(c,a) -> mult.PRESERVATION_radd(q,c) -> mult_commutative(b,c),
# 		mult.L_IDENTITY = |a|mult_commutative(1,a) -> mult.R_IDENTITY(a)
# 	>,
# 	Field := Ring<
# 		|J,0,1,q,'+','-','-','*',add,DISTRIBUTIVE,times_zero_is_zero,equal_core|->,
# 		MINVERSE: [j:J,j!=0]J,
# 		MULTIPLY_R_IDENTITY: [a:J]a*1==a,
# 		MULTIPLY_A_IDENTITY: [a:J,g:a!=0]a*MINVERSE(a,g) == 1,
# 		MULTIPLY_COMMUTATIVE:[a:J,b:J]a*b==b*a,
# 		MULTIPLY_ASSOCIATIVE:[a:J,b:J,c:J](a*b)*c == a*(b*c),
# 		mult:abelian_group<
# 			|PRESERVATION,PRESERVATION|->,
# 			equal_core=equal_core,
# 			J={j:J,i!:j!=0},
# 			0=(1,q),
# 			'+'=|[a,ag],[b,bg]|(
# 				DEC(a*b==0,
# 					|s|a(
# 						^MULTIPLY_R_IDENTITY(a)->#a == a*1
# 						PRESERVATION(a,^MULTIPLY_A_IDENTITY(b,bg)) -> #a*1 == a*(b/b)
# 						^MULTIPLY_ASSOCIATIVE(a,b,MINVERSE(b,bg)) ->#a*(b/b) == (a*b)/b
# 						PRESERVATION(s,MINVERSE(b,bg)) -> #(a*b)/b == 0/b
# 						MULTIPLY_COMMUTATIVE(0,MINVERSE(b,bg)) ->#0/b == /b*0
# 						times_zero_is_zero(MINVERSE(b,bg)),#/b*0 == 0
# 						a*b!=0
# 					),
# 					|s|s
# 				)
# 			),
# 			'-'=|[a,g]|(
# 				MINVERSE(a,ag),
# 				DEC(MINVERSE(a,ag) == 0,
# 					|s|q(
# 						^times_zero_is_zero(a) -> #a*0=0
# 						PRESERVATION(a,^s) ->#a*1/a=a*0
# 						MULTIPLY_A_IDENTITY(a,s),#1=a*1/a
# 						MINVERSE(a,ag) != 0
# 					),
# 					|s|s
# 				)
# 			),
# 			COMMUTATIVE=|[a,ag],[b,bg]|MULTIPLY_COMMUTATIVE(a,b),
# 			ASSOCIATIVE=|[a,ag],[b,bg],[c,cg]|MULTIPLY_ASSOCIATIVE(a,b,c),
# 			A_IDENTITY=|[a,ag]|MULTIPLY_A_IDENTITY(a,ag),
# 			R_IDENTITY=|[a,ag]|MULTIPLY_R_IDENTITY(a)
# 		>,
# 		mult = mult
# 	},





















# 	Relation_bridge:= {
# 		J:U,
# 		equal_core:Equivalence_relation<J=J>,
# 		'==':=equal_core.'==',
# 		'!=':=equal_core.'!=',
# 		'->':=equal_core.'->',
# 		'^':=equal_core.'^',

# 		core:Semigroup<J=J,equal_core=equal_core>,
# 		'+':=core.'+',
# 		relation:Relation<J=J>,
# 		'=>':=relation.'=>',
# 		'<=':=relation.'<=',
# 		'<<':=relation.'<<',
# 		'>>':=relation.'>>',


# 		antisymmetry:[a?:J,b?:J,a=>b,a<=b]a==b,
# 		translation:[a?:J,b?:J,c?:J,a=>b]a+c=>b+c,

# 		PRESERVATION_eq_l: [a?:J,b?:J,c?:J,q1:a=>b,q2:b==c]a=>c,
# 		PRESERVATION_eq_r: [a?:J,b?:J,c?:J,q1:a==b,q2:b=>c]a=>c,
# 		PRESERVATION_neq_l:[a?:J,b?:J,c?:J,q1:a>>b,q2:b==c]a>>c = DEC(a<=c,|s|q1(PRESERVATION_eq_r(^q2,s)),|s|s),
# 		PRESERVATION_neq_r:[a?:J,b?:J,c?:J,q1:a==b,q2:b>>c]a>>c = DEC(a<=c,|s|q2(PRESERVATION_eq_r(s,^q1)),|s|s)
# 	},

# 	Ring_relation_bridge := Relation_bridge<
# 		core:Ring,
# 		core=core,
# 		scaling:[a?:J,b?:J,c?:J,a=>b,c=>0]a*c=>b*c
# 	>



















# 	Semilattice := {
# 		J:U,
# 		equal_core:Equivalence_relation<J=J>,
# 		'==':=equal_core.'==',
# 		'!=':=equal_core.'!=',
# 		'->':=equal_core.'->',
# 		'^':=equal_core.'^',
# 		'*':[J,J]J,
# 		ASSOCIATIVE:[a:J,b:J,c:J](a*b)*c == a*(b*c),
# 		COMMUTATIVE:[a:J,b:J]a*b == b*a,
# 		INDEPOTENT: [a:J]a*a == a,
# 		PRESERVATION:[a?:J,b?:J,a==b,c:J]a+c == b+c,
# 		PRESERVATION:[a?:J,b?:J,c:J,q:a==b]c+a == c+b = COMMUTATIVE(c,a) -> PRESERVATION(q,c) -> COMMUTATIVE(b,c)
# 	}
# 	Bounded_semilattice := Semilattice<
# 		|J,'*',COMMUTATIVE|->,
# 		0:J,
# 		R_IDENTITY:[a:J]a*0 == a,
# 		L_IDENTITY:[a:J]0*a == a = COMMUTATIVE(0,a) -> R_IDENTITY(a)
# 	>,
# 	Lattice := {
# 		J:U,
# 		equal_core:Equivalence_relation<J=J>,
# 		'==':=equal_core.'==',
# 		'!=':=equal_core.'!=',
# 		'->':=equal_core.'->',
# 		'^':=equal_core.'^',
# 		'&&':[J,J]J,
# 		'$$':[J,J]J,
# 		absorption_join:[a:J,b:J]a&&(a$$b) == a,
# 		absorption_meet:[a:J,b:J]a$$(a&&b) == a,
# 		join:Semilattice<J=J,equal_core=equal_core,'*'='&&',
# 			|PRESERVATION|->,
# 			INDEPOTENT=|a|PRESERVATION(a,
# 				^absorption_meet(a,a)
# 			) -> absorption_join(a,a&&a)#a&&(a$$(a&&a)) == a
# 		>,
# 		meet:Semilattice<J=J,equal_core=equal_core,'*'='$$',
# 			|PRESERVATION|->,
# 			INDEPOTENT=|a|PRESERVATION(a,
# 				^absorption_join(a,a)
# 			) -> absorption_meet(a,a$$a)#a&&(a$$(a&&a)) == a
# 		>
# 	},
# 	Bounded_lattice := Lattice<
# 		|J,'&&','$$',join,meet|->,
# 		T:J,
# 		F:J,
# 		join:Bounded_semilattice<0=T>,
# 		join = join,
# 		meet:Bounded_semilattice<0=F>,
# 		meet = meet,
# 		l_join_domination:[a:J]F&&a == F =
# 			join.PRESERVATION(F,
# 				^meet.L_IDENTITY(a),
# 			) -> absorption_join(F,a),
# 		l_meet_domination:[a:J]T$$a == T =
# 			meet.PRESERVATION(T,
# 				^join.L_IDENTITY(a),
# 			) -> absorption_meet(T,a),
# 		r_join_domination:[a:J]a&&F == F = join.COMMUTATIVE(a,F)->l_join_domination(a), 
# 		r_meet_domination:[a:J]a$$T == T = meet.COMMUTATIVE(a,T)->l_meet_domination(a)
# 	>,
# 	Complemented_lattice := Bounded_lattice<
# 		|J,T,F'&&','$$',join,meet|->,
# 		'!!'[J]J,
# 		complement_join:[a:J]a && !!a == F,
# 		complement_meet:[a:J]a $$ !!a == T
# 	>,
# 	Distributive_lattice := Complemented_lattice<#bounded_lattice but also distributive and complement.
# 		|J,'&&','$$','!!'|->,

# 		distributive_join:[a:J,b:J,c:J]a&&(b$$c) == (a&&b)$$(a&&c),
# 		distributive_meet:[a:J,b:J,c:J]a$$(b&&c) == (a$$b)&&(a$$c),

# 		de_morgan_join:[a:J,b:J]!!(a&&b) == (!!a)$$(!!b) = LKJHLKJHLKJHLKJ,
# 		de_morgan_meet:[a:J,b:J]!!(a$$b) == (!!a)&&(!!b) = KJHLJHLKJHLK

# 	>,#boolean algebra is a complemented distributive lattice.



# 	#abelian + semigroup = ring
# 	#abelian + abelian   = field
# 	#abelian + ring      = module
# 	#abelian + field     = vector space

# 	#distributive, associative, identity.
# 	# module := {
# 	# 	abelian + ring

# 	# },
# 	# vector_space := {
# 	# 	abelian + field

# 	# },


























# ordered groups



# exponentation forms module?

# ints are ring + the group of multiplication. (does distribute...)
# negative negative problem...



# horizontal bound: c
# constant vertical bound >0 (each)
# each must decrease.



# x*x == 2, x>>0

# x == 2/x

# decreasing but always >> 0...

# 2/x >> x   iff   2 >> x


# [n<<a]n<<=a-1



# c:J,
# l:J
# [e:J,e>>0]{
# 	s:J,
# 	s>>0,
# 	[x:J,abs(x-c)<<s]abs(f(x)-l)<<e
# }



# positive values closed under addition and multiplication






}