



	you assume type is Array, then you provide an introduced one... this is impossible, no?
	not neccessarily. you just need to be careful.


homomorphism =/= homotopy (isomporphism)

homomorphism -> specific to group theory structure



homotopy ->function with a perfect inverse

[
	::'builtin.ax'

	groupcore:U = {
		A:U,
		J:[A,A]U,
		J:U = {l:A,r:A,j:[l,r]U},
		0:[a:A]J(a),
		'+':[l:J,r:J<l.r>]J<l.l,r.r>,
		'==':[?a:J,?b:J<a.l,a.r>]a.j==b.j
		ASSOCIATIVE:    [a:J,b:J<a.r>,c:J<b.r>](a+b)+c == a+(b+c),
		'-+-':[?a:J,?b:J<a.l,a.r>,?c:J<a.r>,?d:J<c.l,c.r>,q1:a==b,q2:c==d]a+c==b+d = EQUIVALENCE(PRESERVATION(|r|r+c,q1),PRESERVATION(|g|a+c==b+g,q2)),
		R_IDENTITY:     [a:J]a+0(a.r)==a,
	}
]
{
	semigroup:U = {
		::groupcore,
		L_IDENTITY:[a:J]0(a.l)+a==a,

	}
	group:U = {
		g_core:groupcore,
		::groupcore = g_core,

		'-':[j:J]J<j.r,j.l>,
		'-':[a:J,b:J<j.r=a.r>]J = a+(-b),#language consideration here.
		A_IDENTITY:     [a:J]a-a==0(a.l),
		assoc_eliminate:[a:J,b:J<a.r>](a+b)-b == a =
			ASSOCIATIVE(a,b,-b) ->
			PRESERVATION(|g|a+g,A_IDENTITY(b)) ->#a+0 == a+(b-b)
			R_IDENTITY(a),#a+0=a
		elim:[?b:J,?a:J<b.l,b.l>,q:a+b == b]a == 0(b.l) =
			^assoc_eliminate(a,b) ->
			PRESERVATION(|g|g-b,q) ->
			A_IDENTITY(b)
		elim:[?a:J,?b:J<a.l>,?c:J<a.l,a.r>,q:a+b == c+b]a == c = 
			^assoc_eliminate(a,b) ->
			PRESERVATION(|g|g-b,q) ->
			assoc_eliminate(c,b)
		'-+-':[?a:J,?b:J<a.l,a.r>,?c:J<a.r,a.r>,q1:a==b,q2:c==0(a.r)]a+c==b = q1 -+- q2 -> R_IDENTITY(b),
		B_IDENTITY:     [a:J]-a+a==0(a.r) = elim(assoc_eliminate(-a,a)),
		assoc_eliminate_rev:[a:J,b:J](a-b)+b == a =
			ASSOCIATIVE(a,-b,b) ->
			PRESERVATION(|g|a+g,B_IDENTITY(b)) ->#a+0 == a+(b-b)
			R_IDENTITY(a),#a+0=a
		L_IDENTITY:     [a:J]0(a.l)+a==a  =
			PRESERVATION(|g|g+a,^A_IDENTITY(a)) ->#(a-a)+a
			assoc_eliminate_rev(a,a),
		'-+-':[?c:J,?a:J<c.l,c.l>,?d:J<c.l,c.r>,q1:a==0(c.l),q2:c==d]a+c==d = q1 -+- q2 -> L_IDENTITY(d),
	    nzero_eq_zero:[z:A] -0(z) == 0(z) = elim(L_IDENTITY(0(z))),
	    ::semigroup<g_core,L_IDENTITY>
	}

	abelian_group:U = {
		::group<A={}>,
		COMMUTATIVE:[a:J,b:J]a+b==b+a,
	}

	ring:U = {



	}



	ring,
	module,
	vector space,


	field:U = {
		J:U,
		0:J,
		1:J,
		q:0 != 1,
		'+':[J,J]J,
		'-':[J]J,
		add:abelian_group<J=J,0=0,'-'='-','+'='+'>,
		'-':[a:J,b:J]J = a+(-b),
		'*':[J,J]J,
		MINVERSE: [j:J,j!=0]J,
		MULTIPLY_R_IDENTITY: [a:J]a*1==a,
		MULTIPLY_A_IDENTITY: [a:J,g:a!=0]a*MINVERSE(a,g) == 1,
		MULTIPLY_COMMUTATIVE:[a:J,b:J]a*b==b*a,
		MULTIPLY_ASSOCIATIVE:[a:J,b:J,c:J](a*b)*c == a*(b*c),
		DISTRIBUTIVE:        [a:J,b:J,c:J]a*(b+c) == a*b+a*c,
		times_zero_is_zero:  [a:J]a*0 == 0 = 
			add.elim(
	            ^DISTRIBUTIVE(a,0,0) ->#a*0+a*0 == a*(0+0)
	            PRESERVATION(|r|a*r,add.R_IDENTITY(0))#a*(0+0) == a*0
	        ),
		mult:abelian_group<
			J={j:J,!i:j!=0},
			0=(1,q),
			'+'=|[a,ag],[b,bg]|(
				DEC(a*b==0,
					|s|a(
						^MULTIPLY_R_IDENTITY(a)->#a == a*1
						PRESERVATION(|g|a*g,^MULTIPLY_A_IDENTITY(b,bg)) -> #a*1 == a*(b/b)
						^MULTIPLY_ASSOCIATIVE(a,b,MINVERSE(b,bg)) ->#a*(b/b) == (a*b)/b
						PRESERVATION(|g|g*MINVERSE(b,bg),s) -> #(a*b)/b == 0/b
						MULTIPLY_COMMUTATIVE(0,MINVERSE(b,bg)) ->#0/b == /b*0
						times_zero_is_zero(MINVERSE(b,bg)),#/b*0 == 0
						a*b!=0,
					)
					|s|s
				)
			),
			'-'=|[a,g]|(
				MINVERSE(a,ag),
				DEC(MINVERSE(a,ag) == 0,
					|s|q(
						^times_zero_is_zero(a) -> #a*0=0
	                    PRESERVATION(|r|a*r,^s) ->#a*1/a=a*0
	                    MULTIPLY_A_IDENTITY(a,s),#1=a*1/a
	                    MINVERSE(a,ag) != 0
	                ),
	                |s|s
		        ),
			),
			COMMUTATIVE=|[a,ag],[b,bg]|MULTIPLY_COMMUTATIVE(a,b),
			ASSOCIATIVE=|[a,ag],[b,bg],[c,cg]|MULTIPLY_ASSOCIATIVE(a,b,c),
			A_IDENTITY=|[a,ag]|MULTIPLY_A_IDENTITY(a,ag),
			R_IDENTITY=|[a,ag]|MULTIPLY_R_IDENTITY(a)
		>
	}


	alg_closed_field:U = {
		::field,


	}






total_order:U = {
	J:U,
	'=>':[J,J]U,
	'>>':[a:J,b:J]U = !(b=>a),
	'<=':[a:J,b:J]U = b=>a,
	'<<':[a:J,b:J]U = !(a=>b),
	[a:J,b:J,a=>b,b=>a]a==b,
	[a:J,b:J,c:J,a=>b,b=>c]a=>c,
	[a:J,b:J]!{a>>b,b>>a},
}


ordered?
discrete? cannot be discrete if not (strongly) ordered
complete? cannot be complete if not (strongly) ordered or discrete

discrete_domain:U = {
	::total_order,
	h:J,
	h>>0,
	[k:J,k>>0]k=>h,
}


|induction,induction.predicate|:[
	A:U,
	discrete_domain(A),
	B:[A]U,
	L:[A]{a:J,a=>>0},
	f:[b:A,[c:A,L(c).a<<L(b).a]B(c)]B(b)
]{
    res:[a:A]B(a),#<--- This is the definition of well-formed induction/recursion.
    [a:A]res(a) == f(a,|e,_|res(e))#<--- a recursive function is equal to itself called on itself.
}



complete_domain:U = {
	::total_order,
	|supremum,supremum.under,supremum.over|:[
		P:[J]U,
		a:J,
		b:[x:J,P(x)]x<=a,
		j:J,
		p:P(j),
	]{
		sup:J
		[x:J,P(x)]x<=sup,
		[x:J,x>>sup]!P(x)
	},
	|infimum,infimum.under,infimum.over|:[
		P:[J]U,
		a:J,
		b:[x:J,P(x)]x=>a,
		j:J,
		p:P(j),
	]{
		inf:J,
		[x:J,P(x)]x=>inf,
		[x:J,x<<inf]!P(x)
	}
}







supremum(|j|[x:J,P(x)]x=>j,j,|x,px|px(j,p),j,p)
|x,px|

px:[y:J,P(y)]y=>x

inf.over:[x:J,x>>sup]!P(x)

produce:x=>inf

negate(inf.over(x,px()))


|x,bou|




a group's type can have an ordering operation, but the group itself not be ordered




ordered groups



exponentation forms module?

ints are ring + the group of multiplication. (does distribute...)
negative negative problem...



horizontal bound: c
constant vertical bound >0 (each)
each must decrease.



x*x == 2, x>>0

x == 2/x

decreasing but always >> 0...

2/x >> x   iff   2 >> x


[n<<a]n<<=a-1



c:J,
l:J
[e:J,e>>0]{
	s:J,
	s>>0,
	[x:J,abs(x-c)<<s]abs(f(x)-l)<<e
}






}