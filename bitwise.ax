


Conditionally_noether_relation
Conditionally_noether_relation





EQ_core := [J:U]Equivalence_relation<
	J=J,
	'=='=|a,b|a==b,
	transitive='->',
	reflex=|c|IDENTITY(c),
	symmetric='^'
>
Reals_core := {
	Real:U,
	core:Field<
		|'+','-'|->,
		J=Real,
		equal_core=EQ_core(Real),
		PRESERVATION_radd:|a,b,q,c|PRESERVATION(|g|g+c,q),
		PRESERVATION_inv:|a,b,q|PRESERVATION(|g|-g,q)
	>,
	0:=core.0,
	1:=core.1,
	'+':[a:Real,b:Real]=core.'+'(a,b),
	'-':[a:Real]=core.'-'(a),
	relation:Complete_relation<J=Real>,
	bridge:Ring_relation_bridge<
		|'=>'|->,
		core=core,
		relation=relation,
		PRESERVATION_eq_l:|a,b,c,q1,q2|SUBSTITUTION(|w,_|a=>w,q2,q1),
		PRESERVATION_eq_r:|a,b,c,q1,q2|SUBSTITUTION(|w,_|w=>c,^q1,q2)
	>
	real_modulus := [r:Real]Equivalence_relation<
		|'=='|->,
		J=Real,
		modular:[a:Real]a==a+r
	>
	modular_ring:Commutative_ring<J=Real,'+'='+','-'='-',0=,1=>,
	eq_to_modular:[a:Real,b:Real,q:EQ(Real,a,b)]real_modulus.'=='(a,b) = SUBSTITUTION(|w,_|real_modulus.'=='(a,w),q,real_modulus.reflex(a))
}

INT_core := {
	INT:={r:Real,q!:Reals_core.real_modulus(Reals_core.1).'=='(r,Reals_core.0)},

	core:Commutative_ring<
		J=INT,
		equal_core=EQ_core(INT),
		
	>,
	relation:Dual_conditionally_noetherian_relation<J=INT>,
	bridge:Ring_relation_bridge<core=core,relation=relation>,
	'+'=core.'+',



}



NAT_core:INT_core
NAT:U

'.'[n:NAT,]






NRegister:=[n:NAT]{
	J:=[Boundnat(n)]U,
	equal_core:Equivalence_relation<J=J,
		'=='=|a,b|[c:Boundnat(n)]{fore:[a(c)]b(c),back:[b(c)]a(c)},
		transitive=|a,b,c,q1,q2||_|(|aq|q2.fore(q1.fore(aq)),|bq|q1.back(q2.back(bq))),
		symmetric=|a,b,q||_|(|bq|q.back(bq),|aq|q.fore(aq))
	>,
	ring_core:Ring<J=J,equal_core=equal_core,
		0=|_|!U,
		1=|bn|bn.n == NAT_core.0,
		q=DEC((|_|!U)==(|bn|bn.n == NAT_core.0),
			|s|s(Boundnat_core(n).0)
			|s|s
		),
		overflowcore:[a:J,b:J] = Boundnat_core(n).simple_noetherian_recursion(U,
			|d,R|AT_LEAST_TWO_OF(a(d),b(d),{q:d.n>>0,R(q)})
		),
		addcore:[a:J,b:J]J = |d|XOR(
			XOR(a(d),b(d)),
			{q:d.n>>0,overflowcore(a,b).r(d.minus_one(q))}
		),
		'+'=addcore,


		overflowinvcore:[a:J] = Boundnat_core(n).simple_noetherian_recursion(U,
			|d,R|{a(d),{q:d.n>>0,R(q)}}
		),
		invertcore:[a:J]J = |d|XOR(
			!a(d),
			{q:d.n>>0,overflowinvcore(a,b).r(d.minus_one(q))}
		),
		'-'=invertcore,


		mult_core:[a:J,b:J]J = Boundnat_core(n).simple_noetherian_recursion(J,
			|di,R|addcore(
				|d|{q:d=>di,b(di),a(d.minus(di,q))},
				|d|{q:di.n>>0,R(q,d)}
			)
		),
		'*'=|a,b|mult_core(a,b).r(Boundnat_core(n).max),


		multiplication_workshop:[a:J,b:J] = Boundnat_core(n).simple_noetherian_recursion(
			|di|{
				commutative:[d:Boundnat(di.n)]SYMIMPLIES(mult_core(a,b).r(di,d),mult_core(b,a).r(di,d)),

			},
			|di,R|[
				starter:=multiplicationcore(a,addcore(b,c)).pred(Boundnat_core(n).max),
				downward:[q:di.n>>0]= R(q),
				commutative:[d:Boundnat(di.n)]= d.discrete_induction_step(
					di.n-1
					downward()

				)
			](
				commutative,

			)
		),








		




		DISTRIBUTIVE=|a,b,c|
			multiplicationcore(a,addcore(b,c)).pred(Boundnat_core(n).max)
			#multiplicationcore(a,addcore(b,c)).r(di) == addcore(
				#|d|{
					#addcore(b,c,di),
					#q:d=>di,
					#a(d.minus(di,q))
				#},
				#|d|{
					#q:di.n>>0,
					#multiplicationcore(a,addcore(b,c)).r(di.minus_one(q),di.minus_one_lt(q),
					#d)
				#}
			#)





		
		mult.PRESERVATION_radd:[a?:J,b?:J,a==b,c:J]a*c == b*c,
		add.PRESERVATION_radd:[a?:J,b?:J,a==b,c:J]a+c == b+c,
		add.PRESERVATION_inv:[a?:J,b?:J,a==b]-a == -b,

		mult_commutative:[a:J,b:J]a*b == b*a,
		add.COMMUTATIVE:[a:J,b:J]a+b==b+a,

		mult.ASSOCIATIVE:[a:J,b:J,c:J](a*b)*c == a*(b*c),
		add.ASSOCIATIVE:[a:J,b:J,c:J](a+b)+c == a+(b+c),

		mult.R_IDENTITY:[a:J]a*0==a,
		add.R_IDENTITY:[a:J]a+0==a
		add.A_IDENTITY:[a:J]a-a==0,

	>,
	lattice_core:Distributive_lattice<


	>


}


