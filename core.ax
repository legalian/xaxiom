

[

U:U,#U is special. It is the type that all types and predicates have.
AFF:U,#AFF represents the real numbers
ZERO:AFF,#Only zero and one are initialized this way because they are identities.
ONE:AFF,

EQ:          [A:U,A,A]U,#EQ gets its own special syntax: 1 =(A)= 2, or just 1 == 2 if 1 and 2 have type AFF.
IDENTITY:    [A:U,a:A]a=(A)=a,#IDENTITY -> "all elements of all types are equal to themselves."
EQUIVALENCE: [A:U,B:U,A,A=(U)=B]B,#EQUIVALENCE -> "if A is true, and B is true, and A is equal to B, then B is true." it also has its own syntax: A->(1)
HOMOMORPH:   [A:U,B:U,[A]B,[B]A]A=(U)=B,#HOMOMORPH is a misnomer; functions from A to B and from B to A do not garuntee that A and B are homomorphic, but it does imply that they symmetrically imply each other.
REFLEXIVITY: [A:U,a:A,b:A,b=(A)=a]a=(A)=b,
PRESERVATION:[A:U,B:U,f:[A]B,a:A,b:A,a=(A)=b]f(a) =(B)= f(b),

#Types may be nested and unraveled.
|AND,[ANDACC,ANDACCB],[UNION,MEMBER,MEMBERB,_]|:[A:U,B:[A]U]{#For all (types) and (types derived from the first type)...
    and:U,#...there exists a type which represents the union of the two types.
    |acc,accb|:[c:and]{#Given an element of the type representing the union...
        acc:A,#you may retrieve an element of the first type.
        B(acc)#you may retrieve an element of the second type as well.
    },
    [a:A,b:B(a)]{#Given elements of each type...
        union:and,#you may construct an element of the type representing the union of two types.
        member:acc(union) =(A)= a,#accessing the first element from the union gives you back the same element that you used to construct the union.
        memberb:accb(union) =(B(acc(union)))= b,
        membere:accb(union) =( B(a) )= b
    }
},
#The above block of code is mostly equivalent to the following:
#   AND:[A:U,B:[A]U]U,
#   ANDACC:[A:U,B:[A]U,c:AND(A,|a|B(a))]A,
#   ANDACCB:[A:U,B:[A]U,c:AND(A,|a|B(a))]B(ANDACC(A,|a|B(a),c)),
#   UNION:[A:U,B:[A]U,a:A,b:B(a)]AND(A,|a|B(a)),
#   MEMBER:EQ(A,ANDACC(A,[e]B(e),UNION(A,[c]B(c),a,b)),a),
#   MEMBERB:[A:U,B:[A]U,a:A,b:B(a)]EQ(B(a),ANDACCB(A,|e|B(e),UNION(A,|c|B(c),a,b)),b),



NOT:[A:U]U,#
DOUBLENEG:[A:U]!!A =(U)= A,

ADD:     [AFF,AFF]AFF,
AINVERSE:[AFF]AFF,
MULTIPLY:[AFF,AFF]AFF,
MINVERSE:[a:AFF,a!=ZERO]AFF,
ADD_IDENTITY:                [a:AFF]a+ZERO==a,
ADD_IDENTITY_ANNIHALATE:     [a:AFF]a-a==ZERO,
MULTIPLY_IDENTITY:           [a:AFF]a*ONE==a,
MULTIPLY_IDENTITY_ANNIHALATE:[a:AFF,g:a!=ZERO]a*MINVERSE(a,g) == ONE,
ADD_COMMUTATIVE:             [a:AFF,b:AFF]a+b==b+a,
MULTIPLY_COMMUTATIVE:        [a:AFF,b:AFF]a*b==b*a,
ADD_ASSOCIATIVE:             [a:AFF,b:AFF,c:AFF](a+b)+c == a+(b+c),
MULTIPLY_ASSOCIATIVE:        [a:AFF,b:AFF,c:AFF](a*b)*c == a*(b*c),
DISTRIBUTIVE:                [a:AFF,b:AFF,c:AFF]a*(b+c) == a*b+a*c,

GT:[a:AFF,b:AFF]U,
#the following logic may not seem neccessary or complete without knowing how it translates behind the scenes.
|TRICHOTOMY_E,TRICHOTOMY_G,TRICHOTOMY_NE,TRICHOTOMY_NG|:[a:AFF,b:AFF]{
    [a=>>b,a<<=b]a==b,
    [a!=b,a=>>b]a>>b,
    [a>>b]a!=b,
    [a==b]a=>>b
},
|ADDITIVE,MULTIPLICATIVE,FLIPPEDMULTIPLICATIVE|:[a:AFF,b:AFF,a>>b] {
    [c:AFF,d:AFF,c=>>d]a+c>>b+d,
    [c:AFF,c>>ZERO]a*c>>b*c,
    [c:AFF,c<<ZERO]a*c<<b*c
},
|DEC,DEC_POSITIVE,DEC_NEGATIVE|:[T:U,K:U,a:[K]T,b:[NOT(K)]T]{
    dec:T,#<--- This is the definition of a conditional.
    [k:K]     dec=(T)=a(k),#<--- When the conditional's predicate is true, the conditional's result is equal to its first argument.
    [k:NOT(K)]dec=(T)=b(k)#<--- When the conditional's predicate is false, the conditional's result is equal to its second argument.
},
|INDUCTION,INDUCTIONPRED|:[A:U,B:[A]U,L:[A]AFF,f:[b:A,[c:A,L(c)+ONE<<=L(b),L(b)>>ZERO]B(c)]B(b)]{
    res:[a:A]B(a),#<--- This is the definition of well-formed induction/recursion.
    [a:A]res(a) =(B(a))= f(a,|e,_,_|res(e))#<--- a recursive function is equal to itself called on itself.
},

HEAP:U,
ACC:[HEAP]AFF

#NAT:U <--- this is an excellent test

]{



#INT:U = {a:AFF,},
#NAT:U = {a:AFF,a =>> ZERO},
NAT:U = AFF,





Array:U = {
    J:U,
    ara:NAT,
    f:[n:NAT,n << ara]J,
    each:[
        P:[J,n:NAT,n << ara]U
    ]U = {
        q:[n:NAT,q:n << ara]P(f(n,q),n,q)
    }
},



Tree:U = {
    J:U,
    root:J,
    f:[J]Array<J>,
    l:[J]NAT,
    q1:[j:J]f(j).each(|g,_,_|l(g)+ONE <<= l(j)),
    q2:[j:J,l(j) =(AFF)= ZERO]f(j).ara =(AFF)= ZERO,

    each: [
        K:U,
        P:[J,K]U,
        k:K,

        r:[j:J,k:K,P(j,k)]Array<K,f(j).ara>
    ]U = {
        INDUCTION({J,K},|_|U,|[j,_]|l(j),(root,k),|[j,k],R|{
            p:P(j,k),
            f(j).each(|g,q3,q4|
                R(
                    (g,r(j,k,p).f(q3,q4)),
                    ~,#q1(q3,q4),
                    ~
                    #[q5]~#<q2(q5),q3,q4>
                )
            )
        })
    }
}







}





 




