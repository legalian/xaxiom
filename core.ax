

[



AFF:U,#AFF represents the real numbers
0:AFF,#Only zero and one are initialized this way because they are identities.
1:AFF,#real programmers don't need anymore numbers


'+':     [AFF,AFF]AFF,
'-':     [AFF]AFF,
'-':     [a:AFF,b:AFF]AFF = a+(-b),
'*':     [AFF,AFF]AFF,
MINVERSE:[a:AFF,q!:a!=0]AFF,



ADD_IDENTITY:                [a:AFF]a+0==a,
ADD_IDENTITY_ANNIHALATE:     [a:AFF]a-a==0,
ADD_ASSOCIATIVE:             [a:AFF,b:AFF,c:AFF](a+b)+c == a+(b+c),
ADD_COMMUTATIVE:             [a:AFF,b:AFF]a+b==b+a,
MULTIPLY_IDENTITY:           [a:AFF]a*1==a,
MULTIPLY_IDENTITY_ANNIHALATE:[a:AFF,g!:a!=0]a*MINVERSE(a,g) == 1,
MULTIPLY_COMMUTATIVE:        [a:AFF,b:AFF]a*b==b*a,
MULTIPLY_ASSOCIATIVE:        [a:AFF,b:AFF,c:AFF](a*b)*c == a*(b*c),
DISTRIBUTIVE:                [a:AFF,b:AFF,c:AFF]a*(b+c) == a*b+a*c,

'>>': [a:AFF,b:AFF]U,
'=>>':[a:AFF,b:AFF]U = !(b>>a),
'<<': [a:AFF,b:AFF]U = (b>>a),
'<<=':[a:AFF,b:AFF]U = !(a>>b),

ONE_GT_ZERO: 1 >> 0,

|TRICHOTOMY_EQUAL,TRICHOTOMY_GREATER|:[a:AFF,b:AFF]{
    {a=>>b,a<<=b} == (a==b),
    {a!=b,a=>>b} == a>>b
},
|ADDITIVE,MULTIPLICATIVE,NEGATIVECOMP|:[a?:AFF,b?:AFF,a>>b] {
    [c?:AFF,d?:AFF,c=>>d]a+c>>b+d,
    [c?:AFF,c>>0]a*c>>b*c,
    -a << -b
},

# should not be a(k) and b(k), should be DEC(CONTRADICT()).

|DEC,DEC.POSITIVE,DEC.NEGATIVE|:[T?:U,K:U,a:[K]T,b:[!K]T]{
    dec:T,#<--- This is the definition of a conditional.
    [k:K] dec==a(k),#<--- When the conditional's predicate is true, the conditional's result is equal to its first argument.
    [k:!K]dec==b(k)#<--- When the conditional's predicate is false, the conditional's result is equal to its second argument.
},
|'.'positive,'.'negative|:[K?:U,a?:[K]U,b?:[NOT(K)]U,coc:U = DEC(K,|x|a(x),|x|b(x)),dec:coc]{
    [pos:K]a(pos) = EQUIVALENCE(dec,coc.POSITIVE(pos)),
    [neg:!K]b(neg) = EQUIVALENCE(dec,coc.NEGATIVE(neg))
},
# review positive and negative.


|INDUCTION,INDUCTION.PREDICATE|:[A:U,B:[A]U,L:[A]{a:AFF,a=>>0},f:[b:A,[c:A,L(c).a+1<<=L(b).a]B(c)]B(b)]{
    res:[a:A]B(a),#<--- This is the definition of well-formed induction/recursion.
    [a:A]res(a) == f(a,|e,_|res(e))#<--- a recursive function is equal to itself called on itself.
},
'.'predicate:[A?:U,L?:[A]{a:AFF,a=>>0},f?:[b:A,[c:A,L(c).a+1<<=L(b).a]U]U,coc:U = INDUCTION(A,|_|U,|a|L(a),|a,R|f(a,|x,y|R(x,y))),ind:coc]f(a,|e,_|res(e)) = EQUIVALENCE(ind,coc.PREDICATE),



# review predicate


# overload nat addition and positive addition.


|TRICHOTOMY_E,TRICHOTOMY_G,TRICHOTOMY_NE,TRICHOTOMY_NG,TRICHOTOMY_W|:[a?:AFF,b?:AFF]{
    [q1:a=>>b,q2:a<<=b]a==b = EQUIVALENCE({a=>>b,a<<=b},a==b,(q1,q2),TRICHOTOMY_EQUAL),
    [q1:a!=b,q2:a=>>b]a>>b  = EQUIVALENCE({a!=b,a=>>b} ,a>>b,(q1,q2),TRICHOTOMY_GREATER),
    [q:a>>b]a!=b  = 
        EQUIVALENCE(
            DEC({a:a=>>b,b:a<<=b},|s|CONTRADICTION(s.a.eval(q),!{a:a=>>b,b:a<<=b}),|s|s),
            PRESERVATION(|y|!y,TRICHOTOMY_EQUAL(a,b))
        ),
    [q:a==b]a=>>b = 
        EQUIVALENCE(
            DEC({a:a!=b,b:a=>>b},|s|CONTRADICTION(s.a.eval(q),!{a:a!=b,b:a=>>b}),|s|s),
            PRESERVATION(|y|!y,TRICHOTOMY_GREATER(a,b))
        ),
    [q:a>>b]a=>>b = 
        EQUIVALENCE(
            DEC({a:a!=b,b:a=>>b},|s|CONTRADICTION(s.b.eval(q),!{a:a!=b,b:a=>>b}),|s|s),
            PRESERVATION(|y|!y,TRICHOTOMY_GREATER(a,b))
        )
},

INV_CONTRACTIBLE:[J?:U,q1:!J,q2:!J]q1==q2 =
    (!J).equal(
        q1,q2,
        |n|CONTRADICTION(q1.eval(n),q1.eval(n)==q2.eval(n))
    ),
AFFINE_CONTRACTIBLE:[a?:AFF,b?:AFF,q1:a==b,q2:a==b]q1==q2 = 
    UNIVALENCE_TOOLS.equiv_contract(
        TRICHOTOMY_EQUAL(a,b),
        |c,d|UNION_TOOLS.distributive_contractability(a=>>b,a<<=b,
            |e,f|INV_CONTRACTIBLE(e,f),
            |e,f|INV_CONTRACTIBLE(e,f),
            c,
            d
        ),
        q1,
        q2
    ),
GT_CONTRACTIBLE:[a?:AFF,b?:AFF,q1:a>>b,q2:a>>b]q1==q2 = 
    UNIVALENCE_TOOLS.equiv_contract(
        TRICHOTOMY_GREATER(a,b),
        |c,d|UNION_TOOLS.distributive_contractability(a!=b,a=>>b,
            |e,f|INV_CONTRACTIBLE(e,f),
            |e,f|INV_CONTRACTIBLE(e,f),
            c,
            d
        ),
        q1,
        q2
    ),
doublenot_pos:[J?:U,j:!!J]J = 
    DEC(J,
        |s|s,
        |s|CONTRADICTION(j.eval(s))
    ),
doublenot_neg:[J?:U,j:J]!!J = 
    DEC(!J,
        |s|CONTRADICTION(s.eval(j),!!J),
        |s|s
    ),

ALGEBRA_TOOLS: {
    negative_is_multiplication:[a:AFF,b:AFF] -a*b == a*(-b) = 
        ^ADD_IDENTITY(-a*b) -> 
        ADD_COMMUTATIVE(-a*b,0) ->#-a*b == 0-a*b
        ^PRESERVATION(#(a*(-b) + a*b)  -a*b == 0 -a*b # 0 -a*b == (a*(-b) + a*b) -a*b
            |r|r-a*b,
            ^DISTRIBUTIVE(a,-b,b) ->#a*(-b)+a*b == a*(-b+b)
            PRESERVATION(#
                |r|a*r,
                ADD_COMMUTATIVE(-b,b) -> ADD_IDENTITY_ANNHIALATE(b)
            ) ->
            times_zero_is_zero(a)
        ) ->
        assoc_eliminate_add(a*(-b),a*b),#(a*(-b) + a*b) -a*b  == a*(-b)




    compare_transitive_ge:[a?:AFF,b?:AFF,c?:AFF,q1:a>>b,q2:b=>>c]a>>c =
        SUBSTITUTION(
            |g,_|g>>b,
            assoc_eliminate_add(a,b),#(a+b)-b == a
            SUBSTITUTION(
                |g,_|(a+b)-b>>g,
                PRESERVATION(|g|g-b,ADD_COMMUTATIVE(b,c)) -> assoc_eliminate_add(c,b),#(b+c)-b == b
                ADDITIVE(ADDITIVE(q1,q2),TRICHOTOMY_NG(IDENTITY(-b)))
            )
        ),
    compare_transitive_eg:[a?:AFF,b?:AFF,c?:AFF,q1:a=>>b,q2:b>>c]a>>c =
        SUBSTITUTION(
            |g,_|g>>b,
            PRESERVATION(|g|g-b,ADD_COMMUTATIVE(b,a)) -> assoc_eliminate_add(a,b),#(b+a)-b == a
            SUBSTITUTION(
                |g,_|(a+b)-b>>g,
                assoc_eliminate_add(c,b),#(c+b)-b == c
                ADDITIVE(ADDITIVE(q2,q1),TRICHOTOMY_NG(IDENTITY(-b)))
            )
        ),
    compare_transitive_e:[a?:AFF,b?:AFF,c?:AFF,q1:a=>>b,q2:b=>>c]a=>>c =
        DEC(a==b,
            |s|SUBSTITUTION(|w,_|w=>>c,^s,q2),
            |s|TRICHOTOMY_G(s,q1)
        ),

    compare_transitive_ge:[a?:AFF,b?:AFF,c?:AFF,q1:a>>b,q2:b>>c]a>>c = compare_transitive_ge(q1,TRICHOTOMY_W(q2)),

    |additive_e,multiplicative_e,negativecomp_e|:[a?:AFF,b?:AFF,q1:a=>>b] {
        [c?:AFF,d?:AFF,q2:c=>>d]a+c=>>b+d =
            DEC(a==b,
                |g|DEC(c==d,
                    |y|TRICHOTOMY_NG(add_equations(g,y)),
                    |y|SUBSTITUTION(
                        |w,_|w=>>b+d,
                        ADD_COMMUTATIVE(c,a),
                        SUBSTITUTION(
                            |w,_|c+a=>>w,
                            ADD_COMMUTATIVE(d,b),
                            ADDITIVE(TRICHOTOMY_G(y,q2),TRICHOTOMY_NG(g))
                        )
                    )
                ),
                |g|ADDITIVE(TRICHOTOMY_G(g,q1),q2)
            )#,
        # [c?:AFF,q2:c=>>0]a*c=>>b*c = 
        #     DEC(c==0,
        #         |g|TRICHOTOMY_NG(
        #             PRESERVATION(|y|a*y,g) ->
        #             times_zero_is_zero(a) ->
        #             ^times_zero_is_zero(b) ->
        #             ^PRESERVATION(|y|b*y,g)
        #         ),
        #         |g|DEC(a==b,
        #             |y|,
        #             |y|TRICHOTOMY_W(MULTIPLICATIVE(TRICHOTOMY_G(y,q1),TRICHOTOMY_G(g,q2)))
        #         )
        #     ),
        # -a <<= -b = 
        #     DEC(a==b,
        #         |g|TRICHOTOMY_NG(^PRESERVATION(|w|-w,g)),
        #         |g|TRICHOTOMY_W(NEGATIVECOMP(TRICHOTOMY_G(g,q1)))
        #     )
    },
    minus_one_less:[a:AFF]a-1<<a =
        SUBSTITUTION(
            |g,_|a-1<<g,
            PRESERVATION(|g|a+g,nzero_eq_zero) -> ADD_IDENTITY(a),#a-0 == a
            ADDITIVE(IDENTITY(a),NEGATIVECOMP(ONE_GT_ZERO))#a-1<<a-0
        ),
    minus_one_lteq:[a:AFF](a-1)+1<<=a =
        TRICHOTOMY_NG(assoc_eliminate_add_ref(a,1)),
    trico_translate:[x?:AFF,a?:AFF,q:x=>>a]x-a=>>0 = 
        SUBSTITUTION(
            |g,_|x-a>>g,
            ADD_IDENTITY_ANNHIALATE(a),#a-a=0
            ALGEBRA_TOOLS.additive_e(q,TRICHOTOMY_NG(IDENTITY(-a)))#x-a=>>a-a
        ),

    both_greater_zero_add:[a?:AFF,b?:AFF,q1:a=>>0,q2:b=>>0]a+b=>>0 = 
        SUBSTITUTION(
            |w,_|a+b=>>w,
            ADD_IDENTITY(0),
            additive_e(q1,q2)
        ),
    both_greater_zero_mult:[a?:AFF,b?:AFF,q1:a=>>0,q2:b=>>0]a*b=>>0 = 
        SUBSTITUTION(
            |w,_|a*b=>>w,
            times_zero_is_zero(0),
            multiplicative_e(q1,q2)
        ),


    greater_add_both:[a?:AFF,q1:a=>>0,c:AFF]a+c=>>c = 
        SUBSTITUTION(
            |w,_|a+c=>>w,
            ADD_COMMUTATIVE(0,c)->ADD_IDENTITY(c),
            additive_e(q1,TRICHOTOMY_NG(IDENTITY(c)))
        )


},


NAT_TOOLS: {

    #you could provide an alternate group name for induction/inductionpred, or 
    #you could allow a group of variables to be referenced at once, or
    #you could give induction itself a property <-- might also allow for overloads...
    #A(...).eq(adsfkl) <-- implicit parameters bound.

    #referencetree.X now works... 
    #reftree.X can usually substitute out, right? (whenever it is defined on the class, it can.) it at least has all neccessary data.
    #() cannot be a type, <> carries through, {} has it taken care of already, which just leaves x()

    #these propreties ARE NOT the same as inherited properties becuase they CANNOT BE STORED ON THE STRATEGY itself. Rather, they are an extension to the scope object(new)
    #they may not all be immediately consumed... n.q.predicate, for example.

    # contractible labels assign IDS to everything when they substitute down. That way, substitution can do each element of a label in 1 pass.


    isnat:[a:AFF,g!:a=>>0]U = 
        INDUCTION(
            {a:AFF,a=>>0},|_|U,|x|x,
            |[x,_],R|DEC(x<<1,|s|x==0,|s|R(
                (x-1,ALGEBRA_TOOLS.trico_translate(s)),
                ALGEBRA_TOOLS.minus_one_lteq(x)
            )),
            (a,g)
        ),
    # isnat_positive:[a:AFF,g:a=>>0,s:a<<1] isnat(a,g)  == (a==0) = 
    #     isnat(a,g).predicate -> isnat(a,g).predicate..b.positive(s)
    # isnat_negative:[a:AFF,g:a=>>0,s:a=>>1] isnat(a,g) == isnat(a-1,ALGEBRA_TOOLS.trico_translate(s)) = 
    #     isnat(a,g).predicate -> isnat(a,g).predicate.b.negative(s)
    # isnat_occ_positive:[?a:AFF,?g:a=>>0,q:isnat(a,g),s:a<<1]a==0 = 
    #     EQUIVALENCE(q,isnat_positive(a,g,s))
    # isnat_occ_negative:[?a:AFF,?g:a=>>0,q:isnat(a,g),s:a=>>1]isnat(a-1,ALGEBRA_TOOLS.trico_translate(s)) = 
    #     EQUIVALENCE(q,isnat_negative(a,g,s))

    isnat_contractible:[a?:AFF,g?:a=>>0,u:isnat(a,g),v:isnat(a,g)]u==v = 
        INDUCTION({a:AFF,g:a=>>0,u:isnat(a,g),v:isnat(a,g)},|[a,g,u,v]|u==v,|[a,g,u,v]|(a,g),|[a,g,u,v],R|
            DEC(a<<1,
                |s|
                new_u ~= SUBSTITUTION(|w,wq|w,isnat(a,g).POSITIVE(s),u);
                new_v ~= SUBSTITUTION(|w,wq|w,isnat(a,g).POSITIVE(s),v);
                substitute_injective(
                    |w,wq|w,
                    u,v,
                    isnat(a,g).POSITIVE(s),
                    AFFINE_CONTRACTIBLE(new_u,new_v)
                ),
                |s|
                new_u ~= SUBSTITUTION(|w,wq|w,isnat(a,g).NEGATIVE(s),u);
                new_v ~= SUBSTITUTION(|w,wq|w,isnat(a,g).NEGATIVE(s),v);
                substitute_injective(
                    |w,wq|w,
                    u,v,
                    isnat(a,g).NEGATIVE(s),
                    R((a-1,ALGEBRA_TOOLS.trico_translate(s),new_u,new_v),ALGEBRA_TOOLS.minus_one_lteq(a))
                )
            ),
            (a,g,u,v)
        ),
    # isnat.generic:[?a:AFF,?b:AFF,q:a==b,g:a=>>0,j:b=>>0,p:isnat(a,g)]isnat(b,j) ~= 

    #     SUBSTITUTION(
    #         |w,wq|isnat(
    #             w,
    #             SUBSTITUTION(|v,_|v=>>0,wq,g)
    #         ),
    #         q,
    #     )



    ok here's a problem

    you have a template load all of its properties into a type, right?

    then you try to infer a type from the verified empty object.

    even though it's verified, it still has no clue how much it should cast.

    throw an error when that happens so you can manually enter the necessary data.


    NAT:U = {
        a:AFF,
        !g:a=>>0,
        !q:isnat(a,g)
    },
    BOUNDNAT:[e:NAT]U = {
        n:NAT,
        !q:n.a << e.a
    },
    .minus_one:[n:NAT,s:n.a=>>1]:NAT = 
        inner ~= EQUIVALENCE(n.q,n.q.predicate); (
            n.a-1,
            ALGEBRA_TOOLS.trico_translate(s),
            inner.negative(s)
        ),

    .minus_one:[?e:NAT,bn:BOUNDNAT(e),s:n.a=>>1]:BOUNDNAT = 
        (
            bn.n.minus_one(s),
            compare_transitive_g(bn.b,minus_one_less(bn.n.a))
        )


    nat0:NAT = (
        0,
        g=TRICHOTOMY_NG(IDENTITY(0)),
        EQUIVALENCE(
            IDENTITY(0),
            ^isnat(0,g).POSITIVE(ONE_GT_ZERO)
        )
    ),
    nat1:NAT = (
        1,
        g=TRICHOTOMY_W(ONE_GT_ZERO),
        EQUIVALENCE(
            SUBSTITUTION(
                |w,wq|isnat(w,TRICHOTOMY_NG(^wq)),
                ^ADD_IDENTITY_ANNHIALATE(1),
                nat0.q
            ),
            ^isnat(1,g).NEGATIVE(TRICHOTOMY_NG(IDENTITY(1)))
        )
    ),

    nats_be_equal:[a:NAT,b:NAT,q:a.a==b.a]a==b = 
        NAT.equal(
            a,b,
            q,
            IDENTITY({g:w=>>0,isnat(w,g)},(b.g,b.q))
            # an ~= SUBSTITUTION(|w,_|{!g:w=>>0,!q:isnat(w,g)},q,(a.g,a.q));
            # {!g:b.a=>>0,!q:isnat(b.a,g)}.equal(
            #     INV_CONTRACTIBLE(an.g,b.g),
            #     aq ~= SUBSTITUTION(|w,_|isnat(b.a,w),INV_CONTRACTIBLE(an.g,b.g),a.q);
            #     isnat_contractible(aq,b.q)
            # )
        ),


    boundnats_be_equal:[?s:NAT,a:BOUNDNAT(s),b:BOUNDNAT(s),q:a.n.a==b.n.a]a==b = 
        BOUNDNAT.equal(
            a,b,
            nats_be_equal(a.n,b.n,q),
            IDENTITY(b.q)
        ),


    simple_nat_induction:[
        n:NAT,
        P:[a:NAT,a.a<<=n.a]U,
        base:P(nat0),
        rec:[a:NAT,q:a.a=>>1,P(a.minus_one(q))]P(a)
    ]P(n) = INDUCTION(NAT,|n|P(n),|[a,g,_]|(a,g),|n,R|
        DEC(n.a<<1,
            |s|EQUIVALENCE(
                base,
                PRESERVATION(|w|p(w),nats_be_equal(nat0,n,^n.q.positive(s)))
            ),
            |s|rec(n,s,R((n.minus_one(s),ALGEBRA_TOOLS.minus_one_lteq(x))))
        ),n
    ),
    nat_add:[a:NAT,b:NAT]NAT = (
        a.a+b.a,
        ALGEBRA_TOOLS.both_greater_zero_add(a.g,b.g),
        simple_nat_induction(
            b,
            |n|isnat(a.a+n.a,ALGEBRA_TOOLS.both_greater_zero_add(a.g,n.g)),
            SUBSTITUTION(
                |w,wq|isnat(w,TRICHOTOMY_NG(wq)),
                ^ADD_IDENTITY(a.a),
                a.q
            ),
            |n,s,p|EQUIVALENCE(
                SUBSTITUTION(
                    |w,wq|isnat(w,SUBSTITUTION(|v,_|v=>>0,wq,p.g)),
                    ^ADD_ASSOCIATIVE(a.a,n.a,-1),
                    p
                ),
                ^isnat(a.a+n.a,ALGEBRA_TOOLS.both_greater_zero_add(a.g,n.g)).NEGATIVE(s)
            )
        )
    ),
    # nat_subtract:[a:NAT,b:NAT,q:a.a=>>b.a]NAT = (
    #     a.a-b.a,
    #     ALGEBRA_TOOLS.trico_translate(q),
    #     simple_nat_induction(
    #         b,


    #         YOU NEED MORE PROPERTIES....>PAEFJKOIWJEFOIWEJFOIWJEFO


    #         |n|isnat(a.a-n.a,ALGEBRA_TOOLS.trico_translate(a.a,n.a)),
    #         SUBSTITUTION(
    #             |w,wq|isnat(w,TRICHOTOMY_NG(wq)),
    #             ^ADD_IDENTITY(a.a) -> PRESERVATION(|w|a.a+w,^nzero_eq_zero),
    #             a.q
    #         ),
    #         |n,s,p|EQUIVALENCE(
    #             SUBSTITUTION(
    #                 |w,wq|isnat(w,SUBSTITUTION(|v,_|v=>>0,wq,p.g)),
    #                 ^ADD_ASSOCIATIVE(a.a,-n.a,-1),
    #                 p
    #             ),
    #             ^isnat(a.a-n.a,ALGEBRA_TOOLS.trico_translate(a.a,n.a)).negative(s)
    #         )
    #     )
    # ),
    nat_mult:[a:NAT,b:NAT]NAT = (
        a.a*b.a,
        ALGEBRA_TOOLS.both_greater_zero_mult(a.g,b.g),
        simple_nat_induction(
            b,
            |n|isnat(a.a*n.a,ALGEBRA_TOOLS.both_greater_zero_mult(a.g,n.g)),
            SUBSTITUTION(
                |w,wq|isnat(w,TRICHOTOMY_NG(wq)),
                ^times_zero_is_zero(a.a),
                nat0.q
            ),
            |n,s,p|EQUIVALENCE(
                added ~= nat_add((a.a*(n.a-1),p.g,p),a).q;#isnat(a.a*(n.a-1),<><>)
                SUBSTITUTION(
                    |w,wq|isnat(w,SUBSTITUTION(|v,_|v=>>0,wq,added.g)),
                    PRESERVATION(
                        |w|(a.a*n.a+w)+a.a,
                        ^negative_is_multiplication(a.a,-1) ->
                        PRESERVATION(
                            |w|-w,
                            MULTIPLY_IDENTITY_ANNIHALATE(a.a)
                        )
                    ) ->
                    assoc_eliminate_add_ref(a.a*n.a,a.a),
                    added
                ),
                ^isnat(a.a-n.a,ALGEBRA_TOOLS.both_greater_zero_mult(a.g,n.g)).NEGATIVE(s)
            )
        )
    ),

    NAT.'+' = nat_add,
    NAT.'*' = nat_mult,
    NAT.'-' = nat_subtract,

},




]{






























}





 




